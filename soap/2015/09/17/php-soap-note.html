<!DOCTYPE html>
<html>

  <head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习 PHP SOAP 扩展的一些笔记</title>
	<meta name="description" content="如何理解因为 SOAP Web 服务是基于 HTTP 协议的，发出一个 SOAP 消息请求，实际上利用 HTTP 动词中的 POST，然后把 SOAP 消息放置在 HTTP body 里面发送。简单来说就是：每调用一次 SOAP 服务，就是发送一条 POST 请求。下面是一次请求接口所发送的内容：POST /we...">
	
	<link rel="icon" type="image/png" href="/blog/favicon.png" sizes="32x32">
	
	
	<link rel="stylesheet" href="/blog/main.css">
	
</head>

  <body>

	<div class="pagehead">
		<div class="container">
			<h1>
				<a href="/blog/" id="blog-home"><span class="octicon octicon-home" title="返回首页"></span></a>
				<a href="/blog/soap/2015/09/17/php-soap-note.html" class="blog-title">学习 PHP SOAP 扩展的一些笔记</a>
			</h1>
		</div>
	</div>

    <div class="page-content">
      <div class="wrapper">
        <!-- container-->
		<div class="container">
			<!-- columns-->
			<div class="blog-layout columns">
				<!-- three-fourths column -->
				<div class="three-fourths column">
					<div class="blog-content">
							<ul class="blog-post-meta">
								<li class="meta-item">
									<span class="octicon octicon-calendar"></span>
									2015-09-17
								</li>
								<li class="meta-item">
									<img alt="@aisuhua" src="http://sfault-avatar.b0.upaiyun.com/890/673/890673660-55531aaec3a2a_huge256"  class="author-avatar" height="18" width="18"> <a href="https://github.com/aisuhua">aisuhua</a>
								</li>
								<li class="meta-item">
									<span class="octicon octicon-file-directory"></span>
									<a href="/blog/category/soap">soap</a>
								</li>
							</ul>
							<div class="blog-post-body markdown-body">
								<h2 id="section">如何理解</h2>

<p>因为 SOAP Web 服务是基于 HTTP 协议的，发出一个 SOAP 消息请求，实际上利用 HTTP 动词中的 <code>POST</code>，然后把 SOAP 消息放置在 HTTP body 里面发送。简单来说就是：每调用一次 SOAP 服务，就是发送一条 POST 请求。</p>

<p>下面是一次请求接口所发送的内容：</p>

<pre><code>POST /webservices/qqOnlineWebService.asmx HTTP/1.1
Host: www.webxml.com.cn
Connection: Keep-Alive
User-Agent: PHP-SOAP/5.4.29
Content-Type: application/soap+xml; charset=utf-8; action="http://WebXml.com.cn/qqCheckOnline"
Content-Length: 247

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;env:Envelope
    xmlns:env="http://www.w3.org/2003/05/soap-envelope"
    xmlns:ns1="http://WebXml.com.cn/"&gt;
    &lt;env:Body&gt;
        &lt;ns1:qqCheckOnline&gt;
            &lt;ns1:qqCode&gt;8698053&lt;/ns1:qqCode&gt;
        &lt;/ns1:qqCheckOnline&gt;
    &lt;/env:Body&gt;
&lt;/env:Envelope&gt;
</code></pre>

<p>我们可以看到，一次 SOAP 请求，实际上就是向服务器端发送了一个 <code>POST</code> 请求。而发送的内容正是 SOAP 消息（它表明你本次调用的接口方法以及参数等等）。</p>

<p>这个 POST 请求，有一些特点，比如：它发送的内容类型为：<code>application/soap+xml</code>，用户代理为 <code>PHP-SOAP/5.4.29</code> ，其他特点自己观察，不多说。</p>

<h2 id="soap-">SOAP 扩展的作用</h2>

<p>实际上，既然我们知道请求一次接口只是发送一次 POST 请求，那么我们完全可以使用一些工具或 PHP 本身自带的一些库（比如 curl、fsockopen）模拟发送 POST 请求，而不需要使用 PHP 的 SOAP 扩展。对，没错！在 PHP 还没有提供 SOAP 扩展前，的确很多人也是这样做的。</p>

<p>那干嘛要用 SOAP 扩展呢？ 因为它官网的呗，因为它用 C 语言写的，速度杠杠的，而且封装得很好用，也不需要自己编写繁琐的 XML 代码了，所以就用它。</p>

<p>换句话说，实际上 SOAP 扩展就是一个更好用，速度更快，专门用于处理 SOAP 服务的 HTTP 封装库，没有什么很深奥的东西。</p>

<h2 id="section-1">使用方法</h2>

<p>PHP 的帮助手册，有关于 SOAP 扩展的详细说明文档，已经对如何使用说得很清楚了，特别手册后面的一些用户的评论和贡献的代码片段，基本上可以解决你大部分的问题。下面记录一下自己在开发过程中遇到的一些问题，以及解决的方法和一些需要注意的地方。</p>

<h3 id="wsdl--non-wsdl">WSDL 和 non-WSDL</h3>

<p>现在基本上所有 SOAP Web 服务都提供 WSDL 接口描述文件，所以 non-WSDL 这种模式基本上不用考虑。</p>

<h3 id="soap--1">关于 SOAP 版本</h3>

<p>PHP SOAP 扩展同时支持 SOAP 1.1 和 SOAP 1.2 两个版本。一般来说，现在的接口基本上也同时支持这两个 SOAP 协议版本进行通信，那么在这种情况下，当然是采用高版本的 SOAP 1.2 了。实际上，无论你是使用哪个版本，如果你是使用 SOAP 扩展来调用服务的话，在使用该扩展过程中没有任何区别，对你来说都是一样的。唯一需要你去做的是在 <code>SoapCient</code> 进行初始化时，把 soap_version 设置为 SOAP_1_1 或 SOAP_1_2 即可，就像下面这样：</p>

<pre><code>// SOAP 1.1 
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_1
]);

// SOAP 1.2
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_2
]);
</code></pre>

<h3 id="soapparam--soapvar">SoapParam 和 SoapVar</h3>

<p>上面已经说了，现在的服务基本上都提供 WSDL 描述文件，如果是这样的话，这两个类 <code>SoapParam</code> 和 <code>SoapVar</code> 你基本上可以不用管，因为 SOAP 之所以提供这两个类，主要还是为了 PHP SOAP 扩展能够去使用一些没有 WSDL 描述文件的服务，当然这种情况基本上已经不存在了。</p>

<h3 id="soapcall-">关于 __soapCall 方法</h3>

<p>该方法也一样，一般都它只会用于 non-WSDL 模式下，因为在 WSDL 模式下，完全可以把你需要调用的方法作为 <code>SoapClient</code> 对象的一个方法进行调用。不过，如果调用方法的 uri 与 默认的 uri 不一样时，又或者调用该方法时，你必须为它带上一个 SOAP Header 时，就需要使用 <code>__soapCall</code> 方法了。下面是摘自官方手册的一段话：</p>

<blockquote>
  <p>This is a low level API function that is used to make a SOAP call. Usually, in WSDL mode, SOAP functions can be called as methods of the SoapClient object. This method is useful in non-WSDL mode when soapaction is unknown, uri differs from the default or when sending and/or receiving SOAP Headers.</p>
</blockquote>

<p><code>__soapCall</code> 在使用上与通过方法名直接调用的方式有一些区别。下面我们来看看几个例子。同样的，我们还是使用一个网络上可以免费使用的 SOAP 服务配合我们，该服务的主要作用是通过 QQ 号来查询该用户的在线状态。<a href="http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?op=qqCheckOnline">服务地址</a></p>

<p>下面是请求该服务时，应该发送的 SOAP 消息：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap12:Envelope xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
    &lt;soap12:Body&gt;
        &lt;qqCheckOnline xmlns="http://WebXml.com.cn/"&gt;
            &lt;qqCode&gt;string&lt;/qqCode&gt;
        &lt;/qqCheckOnline&gt;
    &lt;/soap12:Body&gt;
&lt;/soap12:Envelope&gt;
</code></pre>

<p>通过方法名调用该接口：</p>

<pre><code>&lt;?php
$wsdl = 'http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl';
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_2
]);

$client-&gt;qqCheckOnline([
    'qqCode' =&gt; 8698053
]));
</code></pre>

<p>使用 <code>__soapCall</code> 方法调用该接口：</p>

<pre><code>&lt;?php
$wsdl = 'http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl';
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_2
]);

$client-&gt;__soapCall('qqCheckOnline', [
    ['qqCode' =&gt; 8698053]
]);
</code></pre>

<p>重点关注两种调用方式时，参数的不一样。通过方法名直接调用的方式，参数是一维数组，而通过 <code>__soapCall</code> 方法调用时，参数是二维数组，这是它们之间的区别之一。</p>

<p>还有第二个区别，就是 <code>__soapCall</code> 方法可以在调用接口时，添加额外的 SOAP Header，比如这样：</p>

<pre><code>$wsdl = 'http://www.example.com/service.asmx?wsdl';
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_2
]);

$auth = ['sAuthenticate' =&gt; 'ab3cde34f5r4545g'];
$namespace = 'http://www.example.com';

$header = new SoapHeader($namespace, 'AuthenHeader', $auth, false);
$client-&gt;__soapCall("SomeFunction", $parameters, null, $header);
</code></pre>

<p>虽然 <code>SoapClient</code> 也有 <code>__setSoapHeaders</code> 方法，但是它会给该实例的所有方法都添加上 SOAP Header，如果存在有些方法需要 SOAP Header 而有些又不需要的话，那么就必须使用 <code>__soapCall</code> 方法，针对某个方法来添加 SOAP Header 了。</p>

<h3 id="namespace">关于命名空间（namespace）</h3>

<p>实际上，在 WSDL 模式下，如果不需要发送 SOAP Header 的话，那么 <code>namespace</code> 是用不上的，因为 <code>namespace</code> 实际上已经在 WSDL 文件中有所描述了，PHP 的 SOAP 扩展会自动把它从 WSDL 文件中解析出来，用于构造 SOAP 请求。如果 SOAP 消息中，需要添加 SOAP Header 的话，那么必须提供 <code>namespace</code>。举个例子：</p>

<p>比如说，有一个服务它需要你发送的 SOAP 消息中必须有 SOAP Header，像下面一样：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap12:Envelope xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
    &lt;soap12:Header&gt;
        &lt;AuthenHeader xmlns="http://www.example.cn"&gt;
            &lt;sAuthenticate&gt;string&lt;/sAuthenticate&gt;
        &lt;/AuthenHeader&gt;
    &lt;/soap12:Header&gt;
    &lt;soap12:Body&gt;
        &lt;GetUserInfoById xmlns="http://www.example.cn"&gt;
            &lt;UserID&gt;int&lt;/UserID&gt;
        &lt;/GetUserInfoById&gt;
    &lt;/soap12:Body&gt;
&lt;/soap12:Envelope&gt;
</code></pre>

<p>下面是构造该 SOAP 请求的代码：</p>

<pre><code>&lt;?php
$wsdl = 'http://www.example.com/service.asmx?wsdl';
$client = new SoapClient($wsdl, [
    'soap_version' =&gt; SOAP_1_2
]);

$auth = ['sAuthenticate' =&gt; 'ab3cde34f5r4545g'];
$namespace = 'http://www.example.com';

$header = new SoapHeader($namespace, 'AuthenHeader', $auth, false);
$client-&gt;__setSoapHeaders($header);    

$response = $client-&gt;GetUserInfoById([
    'UserID' =&gt; 100
]);
</code></pre>

<p>可以看到，使用 <code>SoapHeader</code> 来构建一个 SOAP Header 时，必须提供 <code>namespace</code>，而且是正确的命名空间。</p>

<p>其实，构造一个 SOAP Header 的方法不止这一种写法，还有其他写法，比如你还可以这样构造与上面一样的 SOAP 消息：</p>

<pre><code>&lt;?php
class AuthenHeader
{
    private $sAuthenticate;
    
    public function __construct($auth)
    {
        $this-&gt;sAuthenticate = $auth;
    }
}

$wsdl = 'http://www.example.com/service.asmx?wsdl';
$client = new SoapClient($wsdl, [ 
    'soap_version' =&gt; SOAP_1_2 
]);

$auth = 'ab3cde34f5r4545g';
$namespace = 'http://www.example.com';

$authenHeader = new AuthenHeader($auth);

$header = new SoapHeader($namespace, 'AuthenHeader', $authenHeader, false);
$client-&gt;__setSoapHeaders($header);

$response = $client-&gt;GetUserInfoById([ 
    'UserID' =&gt; 100 
]);
</code></pre>

<p>关于 <code>SoapHeader</code> 其他更多的用法，推荐翻阅 PHP 手册中的 <a href="http://php.net/manual/zh/book.soap.php">SOAP 章节</a>。</p>

<h3 id="soapfault">关于 SoapFault</h3>

<p>服务端在处理客户端请求发生错误时，将会抛出 SoapFault 异常。对于 SOAP 扩展中，哪些方法可能会抛出异常可以查看手册。一旦发生了异常，我们都应该捕捉它们，并妥善处理。像下面这样：</p>

<pre><code>try {
    $client = new SoapClient($wsdl, [
        'trace' =&gt; true,
        'soap_version' =&gt; SOAP_1_2
    ]);

    .....
} catch(SoapFault $e) {
    //在这里处理异常
}
</code></pre>

<h3 id="getlastrequest--getlastresponse">getLastRequest 和 getLastResponse</h3>

<p>这两个方法可以查看最近一次请求和响应的内容，这两个方法对于调试很有帮助。当然，这两个方法只有在 <code>SoapClient</code> 实例化时，<code>trace</code> 参数设置为 <code>true</code> 才会生效。比如像这样：</p>

<pre><code>&lt;?php
$wsdl = 'http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl';
$client = new SoapClient($wsdl, [
    'trace' =&gt; true,
    'soap_version' =&gt; SOAP_1_2
]);

$client-&gt;qqCheckOnline([
    'qqCode' =&gt; 8698053
]));

echo $client-&gt;__getLastRequest();
echo $client-&gt;__getLastResponse();
</code></pre>

<p>getLastRequest() 输出的内容：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;env:Envelope
    xmlns:env="http://www.w3.org/2003/05/soap-envelope"
    xmlns:ns1="http://WebXml.com.cn/"&gt;
    &lt;env:Body&gt;
        &lt;ns1:qqCheckOnline&gt;
            &lt;ns1:qqCode&gt;8698053&lt;/ns1:qqCode&gt;
        &lt;/ns1:qqCheckOnline&gt;
    &lt;/env:Body&gt;
&lt;/env:Envelope&gt;
</code></pre>

<p>getLastResponse() 输出的内容：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap:Envelope
    xmlns:soap="http://www.w3.org/2003/05/soap-envelope"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;soap:Body&gt;
        &lt;qqCheckOnlineResponse
            xmlns="http://WebXml.com.cn/"&gt;
            &lt;qqCheckOnlineResult&gt;Y&lt;/qqCheckOnlineResult&gt;
        &lt;/qqCheckOnlineResponse&gt;
    &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre>

<h3 id="soapui-">SoapUI 调试工具</h3>

<p>在调试 SOAP 服务接口时，我们可以使用功能强大的 <a href="http://www.soapui.org/">SoapUI</a> 工具，可以很方便地调试接口。</p>

<p><a href="http://7xluvh.com1.z0.glb.clouddn.com/2015-8-18/soapui.png"><img src="http://7xluvh.com1.z0.glb.clouddn.com/2015-8-18/soapui.png" alt="SoapUI" /></a></p>

<h2 id="section-2">总结</h2>

<p>上面都是自己在学习 PHP SOAP 扩展时的一些零散的笔记，如果有不对的地方，希望大家指出，谢谢。</p>

					        </div>
							
							
							
							<!-- blog-copyright -->
							<div class="blog-copyright">
							    <h2 class="blog-copyright-header with-cc">
							    	文档信息
							    </h2>
							    <p class="blog-copyright-description">
							    	版权声明： 署名-非商业性使用-禁止演绎 4.0 国际 (<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank">CC BY-NC-ND 4.0</a>) </a> <br />
									发表日期： 2015年09月17日<br />
									更多内容： <a href="/blog/">The Suhua Blog</a> » <a href="/blog/category/soap">soap</a><br />
									Feed订阅：<a class="rss" href="/blog/feed.xml"><span class="octicon octicon-rss"></span> Subscribe</a><br />
								</p>
							</div>
							
							
							<!-- blog-feedback -->
							<div class="blog-feedback"> 
	<div style="height:30px;"></div>
	 <!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="学习 PHP SOAP 扩展的一些笔记" data-title="学习 PHP SOAP 扩展的一些笔记" data-url="/blog//soap/2015/09/17/php-soap-note.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"suhualbog"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
	
</div>
							
					</div>
				</div> 
				
				<!-- one-fourth column -->
				<div class="one-fourth column">
	<div class="blog-aside">
		<nav class="menu">
		  
		  	
			 	<a class="menu-item" href="/blog/category/php"><span class="counter">1</span>php</a>
			
		  
		  	
				<a class="menu-item selected" href="/blog/category/soap"><span class="counter">4</span>soap</a>
			
		  		  
		</nav>
		<a class="rss" href="/blog/feed.xml">
		    <span class="octicon octicon-rss"></span>
		    Subscribe
		</a>
	</div>
</div> 
				
			</div> 
		</div> 
      </div>
    </div>

    <div class="footer">
	<div class="container">
	  <div class="site-footer">
	    <ul class="site-footer-links">
	      <li><span class="tooltipped tooltipped-n" aria-label="一个记录着我成长历程的博客。">The Suhua Blog</span></li>
	        <li><a href="/blog/">博客</a></li>
	        <li><a href="javascript:void(0);" class="tooltipped tooltipped-ne" aria-label="别急，我还在整理呢~">智库</a></li>
	        <li><a href="https://github.com/aisuhua">Github</a></li>
			<li><a href="http://www.cnblogs.com/isuhua">博客园</a></li>
			<li><a href="http://segmentfault.com/u/aisuhua">Segmentfault</a></li>
			<li><a href="http://www.zhihu.com/people/aisuhua">知乎</a></li>
	        <li><a href="/blog/about/">关于</a></li>
	    </ul>
	  </div>
	</div>
</div>


<script src="/blog/js/anchor.min.js"></script>
<script src="/blog/js/highlight.min.js"></script>


<script>
anchors.add('.markdown-body h2, .markdown-body h3, .markdown-body h4');
hljs.initHighlightingOnLoad();
</script>


  </body>

</html>

