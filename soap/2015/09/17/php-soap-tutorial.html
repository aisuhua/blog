<!DOCTYPE html>
<html>

  <head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PHP SOAP 扩展的使用</title>
	<meta name="description" content="原文地址：PHP SOAP 扩展，本文在原文基础上添加了一些内容和章节，也加入了一些注释，请读者注意。简介PHP 的 SOAP 扩展可以用来提供和使用 Web Services。换句话说，PHP 开发者可以利用这个 PHP 扩展来写他们自己的 Web Services，也可以写一些客户端来使用给定的 Web Se...">
	
	<link rel="icon" type="image/png" href="/blog/favicon.png" sizes="32x32">
	
	
	<link rel="stylesheet" href="/blog/main.css">
	
</head>

  <body>

	<div class="pagehead">
		<div class="container">
			<h1>
				<a href="/blog/" id="blog-home"><span class="octicon octicon-home" title="返回首页"></span></a>
				<a href="/blog/soap/2015/09/17/php-soap-tutorial.html" class="blog-title">PHP SOAP 扩展的使用</a>
			</h1>
		</div>
	</div>

    <div class="page-content">
      <div class="wrapper">
        <!-- container-->
		<div class="container">
			<!-- columns-->
			<div class="blog-layout columns">
				<!-- three-fourths column -->
				<div class="three-fourths column">
					<div class="blog-content">
							<ul class="blog-post-meta">
								<li class="meta-item">
									<span class="octicon octicon-calendar"></span>
									2015-09-17
								</li>
								<li class="meta-item">
									<img alt="@aisuhua" src="http://sfault-avatar.b0.upaiyun.com/890/673/890673660-55531aaec3a2a_huge256"  class="author-avatar" height="18" width="18"> <a href="https://github.com/aisuhua">aisuhua</a>
								</li>
								<li class="meta-item">
									<span class="octicon octicon-file-directory"></span>
									<a href="/blog/category/soap">soap</a>
								</li>
							</ul>
							<div class="blog-post-body markdown-body">
								<p>原文地址：<a href="http://www.yeeyan.org/articles/view/jimmylee/5424">PHP SOAP 扩展</a>，本文在原文基础上添加了一些内容和章节，也加入了一些注释，请读者注意。</p>

<h2 id="section">简介</h2>

<p>PHP 的 SOAP 扩展可以用来提供和使用 Web Services。换句话说，PHP 开发者可以利用这个 PHP 扩展来写他们自己的 Web Services，也可以写一些客户端来使用给定的 Web Services。</p>

<p>PHP5 中的这个 SOAP 扩展目的是为了实现 PHP 对 Web Services 的支持。与其它实现 PHP 对 Web Services 的支持的方法不同，SOAP 扩展是用 C 写的，因此它比其它方法具有速度优势。注：SOAP 扩展是在 PHP5 才开始提供，所以在此之前人们要使用 SOAP 去调用 Web Services 时，一般是使用第三方提供的 SOAP 封装库来实现，比如：<a href="https://github.com/tinoadams/NuSOAP">NuSOAP</a>。</p>

<p>SOAP 扩展支持以下规范：</p>

<ul>
  <li>SOAP 1.1</li>
  <li>SOAP 1.2</li>
  <li>WSDL 1.1</li>
</ul>

<p>SOAP 扩展主要用来处理 RPC 形式的 Web Services。不过，你也可以使用文本形式的 WSDL 文件配合 WSDL 模式的服务端和客户端。</p>

<p>这个扩展使用 <a href="http://www.xmlsoft.org/">GNOME XML</a> 库来处理XML。</p>

<h2 id="section-1">扩展中的类</h2>

<p>这个扩展实现了6个类。其中有三个高级的类，它们的方法很有用，它们是 SoapClient、SoapServer 和SoapFault。另外三个类除了构造器外没有其它别的方法，这三个是低级的类，它们是 SoapHeader、SoapParam 和 SoapVar。</p>

<p>SOAP 扩展关系图：</p>

<p><a href="http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram.png"><img src="http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram.png" alt="SOAP 扩展关系图1" /></a></p>

<p>上图并不是很准确，因为 SoapServer 也可以在响应时发送 SoapHeader。所有会有下面这个更加准确的关系图：</p>

<p><a href="http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram_2.gif"><img src="http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram_2.gif" alt="SOAP 扩展关系图2" /></a></p>

<h3 id="soapclient-">SoapClient 类</h3>

<p>这个类用来使用 Web Services。SoapClient 类可以作为给定 Web Services 的客户端。
它有两种操作形式：</p>

<ul>
  <li>WSDL 模式</li>
  <li>Non-WSDL 模式</li>
</ul>

<p>在 WSDL 模式中，构造器可以使用 WSDL 文件名作为参数，并自动从 WSDL 中提取使用服务时所需要的信息。</p>

<p>Non-WSDL 模式中使用参数来设置使用服务时所需要的信息。这个类有许多可以用来使用服务的有用的方法。其中 SoapClient::__soapCall() 是最重要的。这个方法可以用来调用服务中的某个操作。</p>

<h3 id="soapserver-">SoapServer 类</h3>

<p>这个类可以用来提供 Web Services。与 SoapClient 类似，SoapServer 也有两种操作模式：WSDL 模式和 non-WSDL模式。这两种模式的意义跟 SoapClient 的两种模式一样。在 WSDL 模式中，服务实现了 WSDL 提供的接口；在 non-WSDL 模式中，参数被用来管理服务的行为。</p>

<p>在 SoapServer 类的众多方法中，有三个方法比较重要。它们是 SoapServer::setClass()、SoapServer::addFunction() 和 SoapServer::handle()。</p>

<p>SoapServer::setClass()方法设定用来实现 Web Services 的类。SoapServer::setClass 所设定的类中的所有公共方法将成为 Web Services 的操作（operation）。</p>

<p>SoapServer::addFunction() 方法用来添加一个或多个作为 Web Services 操作（operation）的函数。</p>

<p>SoapServer:: handle() 方法指示 Web Services 脚本开始处理进入的请求。Web Services 脚本是用 PHP 脚本写的一个或多个 SoapServer 对象的实例。尽管你可以有不止一个的 SoapServer 对象，但通常的习惯是一个脚本只拥有一个 SoapServer 实例。在调用 SoapServer::handle() 方法之前，Web Services 脚本会使用设置在 SoapServer 对象实例上的任何信息来处理进入的请求和输出相应的内容。</p>

<h3 id="soapfault-">SoapFault 类</h3>

<p>这个类从 Exception 类继承而来，可以用来处理错误。SoapFault 实例可以抛出或获取 Soap 错误的相关信息并按程序员的要求处理。</p>

<h3 id="soapheader-">SoapHeader 类</h3>

<p>这个类可以用来描述 SOAP headers。它只是一个只包含构造器方法的数据容器。</p>

<h3 id="soapparam-">SoapParam 类</h3>

<p>SoapParam 也是一个只包含构造器方法的数据容器。这个方法可以用来描述传递给 Web Services 操作的参数。在 non-WSDL 模式中这是一个很有用的类，可以用来传递所期望格式的参数信息。</p>

<h3 id="soapvar-">SoapVar 类</h3>

<p>SoapVar 也是一个只包含构造器的低级类，与 SoapHeader 和 SoapParam 类相似。这个类可以用来给一个Web Services 操作传递编码参数。这个类对 non-WSDL 中传递类型信息是非常有用的。</p>

<hr />

<p>注：SoapParam 和 SoapVar 主要用来封装用于放入 SOAP 请求中的数据，他们主要在 non-WSDL 模式下使用。事实上，在 WSDL 模式下，SOAP 请求的参数可以通过数组方式包装，SOAP 扩展会根据 WSDL 文件将这个数组转化成为 SOAP 请求中的数据部分，所以并不需要这两个类。而在 non-WSDL 模式下，由于没有提供 WSDL 文件，所以必须通过这两个类进行包装。</p>

<p>SoapHeader 类用来构造 SOAP 头，SOAP 头可以对 SOAP 的能力进行必要的扩展。SOAP 头的一个主要作用就是用于简单的身份认证。</p>

<h2 id="wsdl-vs-non-wsdl-">WSDL VS. non-WSDL 模式</h2>

<p>Web Services 有两种实现模式：契约先行（Contract first）模式和代码先行（Code first）模式。</p>

<p>契约先行模式使用了一个用 XML 定义的服务接口的WSDL文件。WSDL 文件定义了服务必须实现或客户端可以使用的接口。SoapServer 和 SoapClient 的 WSDL 模式就基于这个概念。</p>

<p>在代码先行模式中，首先要先写出实现服务的代码。然后在大多数情况下，代码会产生一个契约（可以借助一些工具生成），换种说法，一个 WSDL 文件。接着客户端在使用服务的时候就可以使用那个 WSDL 来获得服务的接口及其他信息。尽管如此，PHP5 的扩展并没有从代码输出一个 WSDL 的实现，考虑到这种情况，可以在 non-WSDL 模式下使用 SoapServer 和 SoapClient。</p>

<h2 id="soap--hello-world">使用 SOAP 扩展实现 Hello World</h2>

<p>这一节介绍如何使用 WSDL 模式和 non-WSDL 模式来实现服务和客户端。相对而言，使用 WSDL 模式来实现服务和客户端会比较容易，假定已经有一个定义好了接口的 WSDL 文件。因此这一节会先介绍如何使用 WSDL 模式实现一个 Web Service。</p>

<h3 id="soap-">安装 SOAP 扩展</h3>

<p>对于 Windows 平台，需要在 php.ini 中加入如下代码：</p>

<pre><code>extension = php_soap.dll
</code></pre>

<p>上面的工作完成之后，还需要注意的是 SOAP 扩展在配置文件中有独立的代码片段：</p>

<pre><code>[soap]
; Enables or disables WSDL caching feature.
; http://php.net/soap.wsdl-cache-enabled
soap.wsdl_cache_enabled=1

; Sets the directory name where SOAP extension will put cache files.
; http://php.net/soap.wsdl-cache-dir
soap.wsdl_cache_dir="D:/wamp/tmp"

; (time to live) Sets the number of second while cached file will be used
; instead of original one.
; http://php.net/soap.wsdl-cache-ttl
soap.wsdl_cache_ttl=86400

; Sets the size of the cache limit. (Max. number of WSDL files to cache)
soap.wsdl_cache_limit = 5
</code></pre>

<p>这些配置项主要是用来指定 PHP 处理 WSDL 文件时使用缓存的行为。这几个配置项分别说明：是否开启 WSDL 文件缓存、文件缓存位置、缓存时间、以及最大缓存文件数量。启用缓存会加快 PHP 处理 WSDL 文件的速度，但最好在调试代码时关闭缓存，以避免一些因缓存行为而出现的问题。</p>

<h3 id="wsdl-">WSDL 文件</h3>

<p>在这个 Hello World 例子的服务中有一个被命名为 greet 的操作。这个操作有一个字符串形式的名字参数并返回一个字符串形式的 Hello + 名字。所用到的 WSDL 如下：</p>

<pre><code>&lt;wsdl:definitions
    xmlns:impl='http://localhost/php-soap/wsdl/helloService'
    xmlns:intf='http://localhost/php-soap/wsdl/helloService'
    xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'
    xmlns:wsdlsoap='http://schemas.xmlsoap.org/wsdl/soap/'
    xmlns:xsd='http://www.w3.org/2001/XMLSchema' 
    targetNamespace='http://localhost/php-soap/wsdl/helloService'&gt;
    &lt;wsdl:types&gt;
        &lt;schema elementFormDefault='qualified'
            xmlns:impl='http://localhost/php-soap/wsdl/helloService'
            xmlns:intf='http://localhost/php-soap/wsdl/helloService'
            xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'
            xmlns="http://www.w3.org/2001/XMLSchema" 
            targetNamespace='http://localhost/php-soap/wsdl/helloService' &gt;
            &lt;element name='greet'&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name='name' type='xsd:string' /&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name='greetResponse'&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name='greetReturn' type='xsd:string' /&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
        &lt;/schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name='greetRequest'&gt;
        &lt;wsdl:part name='parameters' element='impl:greet' /&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name='greetResponse'&gt;
        &lt;wsdl:part name='parameters' element='impl:greetResponse' /&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:portType name='helloService'&gt;
        &lt;wsdl:operation name='greet'&gt;
            &lt;wsdl:input name='greetRequest' message='impl:greetRequest' /&gt;
            &lt;wsdl:output name='greetResponse' message='impl:greetResponse' /&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name='helloServiceSoapBinding' type='impl:helloService'&gt;
        &lt;wsdlsoap:binding transport='http://schemas.xmlsoap.org/soap/http' style='document' /&gt;
        &lt;wsdl:operation name='greet'&gt;
            &lt;wsdlsoap:operation soapAction='helloService#greet' /&gt;
            &lt;wsdl:input name='greetRequest'&gt;
                &lt;wsdlsoap:body use='literal' /&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output name='greetResponse'&gt;
                &lt;wsdlsoap:body use='literal' /&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name='helloService'&gt;
        &lt;wsdl:port binding='impl:helloServiceSoapBinding' name='helloService'&gt;
            &lt;wsdlsoap:address location='http://localhost/php-soap/wsdl/hello_service_wsdl.php' /&gt;
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;
</code></pre>

<h3 id="wsdl--1">WSDL 模式服务端</h3>

<p>下面是 WSDL 模式的服务使用 SOAP 扩展来实现提供服务的代码：</p>

<pre><code>&lt;?php
function greet($param)
{
    $value  = 'Hello ' . $param-&gt;name;
    $result = [
        'greetReturn' =&gt; $value
    ];
    return $result;
}

$server = new SoapServer('hello.wsdl');
$server-&gt;addFunction('greet');
$server-&gt;handle();
</code></pre>

<p>在这个服务的实现过程中，函数实现了WSDL所定义的服务操作 greet，greet 操作有一个 WSDL 指定的参数，按照 greet 操作的语义，这个参数是一个用户的名字。最后 handle 调用了触发处理请求的服务对象。</p>

<h3 id="wsdl--2">WSDL 模式客户端</h3>

<p>客户端代码如下:</p>

<pre><code>try {
    $client = new SoapClient('hello.wsdl');
    $result =  $client-&gt;__soapCall('greet', [
        ['name' =&gt; 'Suhua']
    ]);
    printf("Result = %s", $result-&gt;greetReturn);
} catch (Exception $e) {
    printf("Message = %s",$e-&gt;__toString());
}
</code></pre>

<p>客户端代码中，首先创建一个使用 WSDL 文件作参数的 SoapClient 实例。接着使用 __soapCall() 调用 greet 方法，并传入参数。</p>

<p>下面是客户端所发送的 SOAP 请求：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope
    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:ns1="http://localhost/php-soap/wsdl/helloService"&gt;
    &lt;SOAP-ENV:Body&gt;
        &lt;ns1:greet&gt;
            &lt;ns1:name&gt;Suhua&lt;/ns1:name&gt;
        &lt;/ns1:greet&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>

<p>下面是服务端响应上诉请求而发送的 SOAP 响应：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope
    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:ns1="http://localhost/php-soap/wsdl/helloService"&gt;
    &lt;SOAP-ENV:Body&gt;
        &lt;ns1:greetResponse&gt;
            &lt;ns1:greetReturn&gt;Hello Suhua&lt;/ns1:greetReturn&gt;
        &lt;/ns1:greetResponse&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>

<p>上面的 SOAP 消息都是利用 WSDL 模式下的服务端和客户端来获取的（可以使用 __getLastResponse 和 __getLastRequest 这两个方法获取，前提是客户端初始化时，要把 <code>trace</code> 参数设置为 <code>true</code>）。也可以利用 non-WSDL 模式的服务端和客户端来产生与上面相同的 SOAP 消息。但是，PHP 代码必须有一点改变。下一节会说明如何使用 non-WSDL 模式。</p>

<h3 id="non-wsdl-">non-WSDL 模式服务端</h3>

<pre><code>function greet($param)
{
    $value = 'Hello '.$param;
    return new SoapParam($value, 'greetReturn');
}

$server = new SoapServer(null, [
    'uri' =&gt; 'http://localhost/php-soap/non-wsdl/helloService'
]);

$server-&gt;addFunction('greet');
$server-&gt;handle();
</code></pre>

<p>在 non-WSDL 模式中，像 WSDL 模式一样首先实现 greet 函数的功能，但是函数实现的方式跟 WSDL 模式稍稍有所不同。在 non-WSDL 模式中，我们必须返回一个 SoapParam 对象作为响应，而不是一个数组。创建服务时，第一个参数设为 null，说明没有提供 WSDL；接着传递一个选项作为参数，这个选项参数是服务的 URI。最后像 WSDL 模式一样调用剩下的方法。</p>

<h3 id="non-wsdl--1">non-WSDL 模式客户端</h3>

<pre><code>try {
    $client = new SoapClient(null, [
        'location' =&gt; 'http://localhost/php-soap/non-wsdl/hello_service_non_wsdl.php',
        'uri' =&gt; 'http://localhost/php-soap/non-wsdl/helloService'
    ]);

    $result =  $client-&gt;__soapCall('greet', [
        new SoapParam('Suhua', 'name')
    ]);

    printf("Result = %s", $result);
} catch (Exception $e) {
    printf("Message = %s",$e-&gt;__toString());
}
</code></pre>

<p>在 non-WSDL 模式中，因为没有使用 WSDL，传递了一个包含服务所在位置（location）和服务 URI 的参数数组作为参数。然后像 WSDL 模式中一样调用 __soapCall() 方法，但是使用了 SoapParam 类用指定格式打包参数。返回的结果将获取 greet 方法的响应。</p>

<p>注：客户端实例化时所传入的服务 URI，实际上，我们可以把它看作该服务的一个命名空间（namespace）。客户端所传入的 URI 必与服务端所命名的 URI 一样。</p>

<h2 id="section-2">结论</h2>

<p>这篇文章介绍了 SOAP 扩展，可以在 PHP 中通过它来提供和使用 Web Services。PHP SOAP 扩展的强项是它的简单和快速。使用 C 写的 SOAP 扩展来运行服务端和客户端是非常简单的。虽然 SOAP 扩展在处理一些简单的 Web Services 时很有用，但是当用它来处理所有的 Web Services 时就表现出它的局限性。<a href="http://wso2.com/products/web-services-framework/php/">WSO WSF/PHP</a> 就是为了弥补 PHP 扩展的缺陷而开发的，它是开源的，可以实现 SOAP 类似的功能并且支持 MTOM，WS-Addressing，WS- Security 和 WS-RelaiableMessaging。WSO2 WSF/PHP 支持与 SOAP 扩展类似的 API。我们正计划将 API 打包起来提供跟 SOAP 扩展一样的 API，会用 C 来写。</p>

<h2 id="section-3">最后</h2>

<p>这篇文章的原文 <a href="http://wso2.com/library/1060/">PHP SOAP Extension</a>，中文译文 <a href="http://www.yeeyan.org/articles/view/jimmylee/5424">PHP SOAP     扩展</a>。在转载这篇文章的时候，对文章添加了一些注释以及本人的一些见解，而且例子也是重新编写的，所以与原文比会有所不同。本文的所有代码将会被放到 <a href="https://github.com/aisuhua">Github</a> 仓库中，方便以后翻阅和复习。</p>

<h2 id="section-4">参考文献</h2>

<ol>
  <li><a href="http://www.yeeyan.org/articles/view/jimmylee/5424">PHP SOAP 扩展</a></li>
  <li><a href="http://wso2.com/library/1060/">PHP SOAP Extension </a></li>
  <li><a href="http://blog.csdn.net/lfq618/article/details/5514641">PHP SOAP 扩展详解</a></li>
</ol>

					        </div>
							
							
							
							
							<!-- blog-feedback -->
							<div class="blog-feedback"> 
	<div style="height:30px;"></div>
	 <!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="PHP SOAP 扩展的使用" data-title="PHP SOAP 扩展的使用" data-url="/blog//soap/2015/09/17/php-soap-tutorial.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"suhualbog"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
	
</div>
							
					</div>
				</div> 
				
				<!-- one-fourth column -->
				<div class="one-fourth column">
	<div class="blog-aside">
		<nav class="menu">
		  
		  	
			 	<a class="menu-item" href="/blog/category/php"><span class="counter">1</span>php</a>
			
		  
		  	
				<a class="menu-item selected" href="/blog/category/soap"><span class="counter">4</span>soap</a>
			
		  		  
		</nav>
		<a class="rss" href="/blog/feed.xml">
		    <span class="octicon octicon-rss"></span>
		    Subscribe
		</a>
	</div>
</div> 
				
			</div> 
		</div> 
      </div>
    </div>

    <div class="footer">
	<div class="container">
	  <div class="site-footer">
	    <ul class="site-footer-links">
	      <li><span class="tooltipped tooltipped-n" aria-label="一个记录着我成长历程的博客。">The Suhua Blog</span></li>
	        <li><a href="/blog/">博客</a></li>
	        <li><a href="javascript:void(0);" class="tooltipped tooltipped-ne" aria-label="别急，我还在整理呢~">智库</a></li>
	        <li><a href="https://github.com/aisuhua">Github</a></li>
			<li><a href="http://www.cnblogs.com/isuhua">博客园</a></li>
			<li><a href="http://segmentfault.com/u/aisuhua">Segmentfault</a></li>
			<li><a href="http://www.zhihu.com/people/aisuhua">知乎</a></li>
	        <li><a href="/blog/about/">关于</a></li>
	    </ul>
	  </div>
	</div>
</div>


<script src="/blog/js/anchor.min.js"></script>
<script src="/blog/js/highlight.min.js"></script>


<script>
anchors.add('.markdown-body h2, .markdown-body h3, .markdown-body h4');
hljs.initHighlightingOnLoad();
</script>


  </body>

</html>

