<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Suhua Blog</title>
    <description>Hi, This is Suhua Blog.</description>
    <link>http://aisuhua.github.io//blog/</link>
    <atom:link href="http://aisuhua.github.io//blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 30 Sep 2015 10:42:50 +0800</pubDate>
    <lastBuildDate>Wed, 30 Sep 2015 10:42:50 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>学习 PHP SOAP 扩展的一些笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;如何理解&lt;/h2&gt;

&lt;p&gt;因为 SOAP Web 服务是基于 HTTP 协议的，发出一个 SOAP 消息请求，实际上利用 HTTP 动词中的 &lt;code&gt;POST&lt;/code&gt;，然后把 SOAP 消息放置在 HTTP body 里面发送。简单来说就是：每调用一次 SOAP 服务，就是发送一条 POST 请求。&lt;/p&gt;

&lt;p&gt;下面是一次请求接口所发送的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POST /webservices/qqOnlineWebService.asmx HTTP/1.1
Host: www.webxml.com.cn
Connection: Keep-Alive
User-Agent: PHP-SOAP/5.4.29
Content-Type: application/soap+xml; charset=utf-8; action=&quot;http://WebXml.com.cn/qqCheckOnline&quot;
Content-Length: 247

&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;env:Envelope
    xmlns:env=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    xmlns:ns1=&quot;http://WebXml.com.cn/&quot;&amp;gt;
    &amp;lt;env:Body&amp;gt;
        &amp;lt;ns1:qqCheckOnline&amp;gt;
            &amp;lt;ns1:qqCode&amp;gt;8698053&amp;lt;/ns1:qqCode&amp;gt;
        &amp;lt;/ns1:qqCheckOnline&amp;gt;
    &amp;lt;/env:Body&amp;gt;
&amp;lt;/env:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，一次 SOAP 请求，实际上就是向服务器端发送了一个 &lt;code&gt;POST&lt;/code&gt; 请求。而发送的内容正是 SOAP 消息（它表明你本次调用的接口方法以及参数等等）。&lt;/p&gt;

&lt;p&gt;这个 POST 请求，有一些特点，比如：它发送的内容类型为：&lt;code&gt;application/soap+xml&lt;/code&gt;，用户代理为 &lt;code&gt;PHP-SOAP/5.4.29&lt;/code&gt; ，其他特点自己观察，不多说。&lt;/p&gt;

&lt;h2 id=&quot;soap-&quot;&gt;SOAP 扩展的作用&lt;/h2&gt;

&lt;p&gt;实际上，既然我们知道请求一次接口只是发送一次 POST 请求，那么我们完全可以使用一些工具或 PHP 本身自带的一些库（比如 curl、fsockopen）模拟发送 POST 请求，而不需要使用 PHP 的 SOAP 扩展。对，没错！在 PHP 还没有提供 SOAP 扩展前，的确很多人也是这样做的。&lt;/p&gt;

&lt;p&gt;那干嘛要用 SOAP 扩展呢？ 因为它官网的呗，因为它用 C 语言写的，速度杠杠的，而且封装得很好用，也不需要自己编写繁琐的 XML 代码了，所以就用它。&lt;/p&gt;

&lt;p&gt;换句话说，实际上 SOAP 扩展就是一个更好用，速度更快，专门用于处理 SOAP 服务的 HTTP 封装库，没有什么很深奥的东西。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;PHP 的帮助手册，有关于 SOAP 扩展的详细说明文档，已经对如何使用说得很清楚了，特别手册后面的一些用户的评论和贡献的代码片段，基本上可以解决你大部分的问题。下面记录一下自己在开发过程中遇到的一些问题，以及解决的方法和一些需要注意的地方。&lt;/p&gt;

&lt;h3 id=&quot;wsdl--non-wsdl&quot;&gt;WSDL 和 non-WSDL&lt;/h3&gt;

&lt;p&gt;现在基本上所有 SOAP Web 服务都提供 WSDL 接口描述文件，所以 non-WSDL 这种模式基本上不用考虑。&lt;/p&gt;

&lt;h3 id=&quot;soap--1&quot;&gt;关于 SOAP 版本&lt;/h3&gt;

&lt;p&gt;PHP SOAP 扩展同时支持 SOAP 1.1 和 SOAP 1.2 两个版本。一般来说，现在的接口基本上也同时支持这两个 SOAP 协议版本进行通信，那么在这种情况下，当然是采用高版本的 SOAP 1.2 了。实际上，无论你是使用哪个版本，如果你是使用 SOAP 扩展来调用服务的话，在使用该扩展过程中没有任何区别，对你来说都是一样的。唯一需要你去做的是在 &lt;code&gt;SoapCient&lt;/code&gt; 进行初始化时，把 soap_version 设置为 SOAP_1_1 或 SOAP_1_2 即可，就像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// SOAP 1.1 
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_1
]);

// SOAP 1.2
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;soapparam--soapvar&quot;&gt;SoapParam 和 SoapVar&lt;/h3&gt;

&lt;p&gt;上面已经说了，现在的服务基本上都提供 WSDL 描述文件，如果是这样的话，这两个类 &lt;code&gt;SoapParam&lt;/code&gt; 和 &lt;code&gt;SoapVar&lt;/code&gt; 你基本上可以不用管，因为 SOAP 之所以提供这两个类，主要还是为了 PHP SOAP 扩展能够去使用一些没有 WSDL 描述文件的服务，当然这种情况基本上已经不存在了。&lt;/p&gt;

&lt;h3 id=&quot;soapcall-&quot;&gt;关于 __soapCall 方法&lt;/h3&gt;

&lt;p&gt;该方法也一样，一般都它只会用于 non-WSDL 模式下，因为在 WSDL 模式下，完全可以把你需要调用的方法作为 &lt;code&gt;SoapClient&lt;/code&gt; 对象的一个方法进行调用。不过，如果调用方法的 uri 与 默认的 uri 不一样时，又或者调用该方法时，你必须为它带上一个 SOAP Header 时，就需要使用 &lt;code&gt;__soapCall&lt;/code&gt; 方法了。下面是摘自官方手册的一段话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is a low level API function that is used to make a SOAP call. Usually, in WSDL mode, SOAP functions can be called as methods of the SoapClient object. This method is useful in non-WSDL mode when soapaction is unknown, uri differs from the default or when sending and/or receiving SOAP Headers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;__soapCall&lt;/code&gt; 在使用上与通过方法名直接调用的方式有一些区别。下面我们来看看几个例子。同样的，我们还是使用一个网络上可以免费使用的 SOAP 服务配合我们，该服务的主要作用是通过 QQ 号来查询该用户的在线状态。&lt;a href=&quot;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?op=qqCheckOnline&quot;&gt;服务地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是请求该服务时，应该发送的 SOAP 消息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap12:Envelope xmlns:soap12=&quot;http://www.w3.org/2003/05/soap-envelope&quot;&amp;gt;
    &amp;lt;soap12:Body&amp;gt;
        &amp;lt;qqCheckOnline xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
            &amp;lt;qqCode&amp;gt;string&amp;lt;/qqCode&amp;gt;
        &amp;lt;/qqCheckOnline&amp;gt;
    &amp;lt;/soap12:Body&amp;gt;
&amp;lt;/soap12:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过方法名调用该接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$wsdl = &#39;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);

$client-&amp;gt;qqCheckOnline([
    &#39;qqCode&#39; =&amp;gt; 8698053
]));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;__soapCall&lt;/code&gt; 方法调用该接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$wsdl = &#39;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);

$client-&amp;gt;__soapCall(&#39;qqCheckOnline&#39;, [
    [&#39;qqCode&#39; =&amp;gt; 8698053]
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点关注两种调用方式时，参数的不一样。通过方法名直接调用的方式，参数是一维数组，而通过 &lt;code&gt;__soapCall&lt;/code&gt; 方法调用时，参数是二维数组，这是它们之间的区别之一。&lt;/p&gt;

&lt;p&gt;还有第二个区别，就是 &lt;code&gt;__soapCall&lt;/code&gt; 方法可以在调用接口时，添加额外的 SOAP Header，比如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$wsdl = &#39;http://www.example.com/service.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);

$auth = [&#39;sAuthenticate&#39; =&amp;gt; &#39;ab3cde34f5r4545g&#39;];
$namespace = &#39;http://www.example.com&#39;;

$header = new SoapHeader($namespace, &#39;AuthenHeader&#39;, $auth, false);
$client-&amp;gt;__soapCall(&quot;SomeFunction&quot;, $parameters, null, $header);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然 &lt;code&gt;SoapClient&lt;/code&gt; 也有 &lt;code&gt;__setSoapHeaders&lt;/code&gt; 方法，但是它会给该实例的所有方法都添加上 SOAP Header，如果存在有些方法需要 SOAP Header 而有些又不需要的话，那么就必须使用 &lt;code&gt;__soapCall&lt;/code&gt; 方法，针对某个方法来添加 SOAP Header 了。&lt;/p&gt;

&lt;h3 id=&quot;namespace&quot;&gt;关于命名空间（namespace）&lt;/h3&gt;

&lt;p&gt;实际上，在 WSDL 模式下，如果不需要发送 SOAP Header 的话，那么 &lt;code&gt;namespace&lt;/code&gt; 是用不上的，因为 &lt;code&gt;namespace&lt;/code&gt; 实际上已经在 WSDL 文件中有所描述了，PHP 的 SOAP 扩展会自动把它从 WSDL 文件中解析出来，用于构造 SOAP 请求。如果 SOAP 消息中，需要添加 SOAP Header 的话，那么必须提供 &lt;code&gt;namespace&lt;/code&gt;。举个例子：&lt;/p&gt;

&lt;p&gt;比如说，有一个服务它需要你发送的 SOAP 消息中必须有 SOAP Header，像下面一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap12:Envelope xmlns:soap12=&quot;http://www.w3.org/2003/05/soap-envelope&quot;&amp;gt;
    &amp;lt;soap12:Header&amp;gt;
        &amp;lt;AuthenHeader xmlns=&quot;http://www.example.cn&quot;&amp;gt;
            &amp;lt;sAuthenticate&amp;gt;string&amp;lt;/sAuthenticate&amp;gt;
        &amp;lt;/AuthenHeader&amp;gt;
    &amp;lt;/soap12:Header&amp;gt;
    &amp;lt;soap12:Body&amp;gt;
        &amp;lt;GetUserInfoById xmlns=&quot;http://www.example.cn&quot;&amp;gt;
            &amp;lt;UserID&amp;gt;int&amp;lt;/UserID&amp;gt;
        &amp;lt;/GetUserInfoById&amp;gt;
    &amp;lt;/soap12:Body&amp;gt;
&amp;lt;/soap12:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是构造该 SOAP 请求的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$wsdl = &#39;http://www.example.com/service.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);

$auth = [&#39;sAuthenticate&#39; =&amp;gt; &#39;ab3cde34f5r4545g&#39;];
$namespace = &#39;http://www.example.com&#39;;

$header = new SoapHeader($namespace, &#39;AuthenHeader&#39;, $auth, false);
$client-&amp;gt;__setSoapHeaders($header);    

$response = $client-&amp;gt;GetUserInfoById([
    &#39;UserID&#39; =&amp;gt; 100
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，使用 &lt;code&gt;SoapHeader&lt;/code&gt; 来构建一个 SOAP Header 时，必须提供 &lt;code&gt;namespace&lt;/code&gt;，而且是正确的命名空间。&lt;/p&gt;

&lt;p&gt;其实，构造一个 SOAP Header 的方法不止这一种写法，还有其他写法，比如你还可以这样构造与上面一样的 SOAP 消息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class AuthenHeader
{
    private $sAuthenticate;
    
    public function __construct($auth)
    {
        $this-&amp;gt;sAuthenticate = $auth;
    }
}

$wsdl = &#39;http://www.example.com/service.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [ 
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2 
]);

$auth = &#39;ab3cde34f5r4545g&#39;;
$namespace = &#39;http://www.example.com&#39;;

$authenHeader = new AuthenHeader($auth);

$header = new SoapHeader($namespace, &#39;AuthenHeader&#39;, $authenHeader, false);
$client-&amp;gt;__setSoapHeaders($header);

$response = $client-&amp;gt;GetUserInfoById([ 
    &#39;UserID&#39; =&amp;gt; 100 
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 &lt;code&gt;SoapHeader&lt;/code&gt; 其他更多的用法，推荐翻阅 PHP 手册中的 &lt;a href=&quot;http://php.net/manual/zh/book.soap.php&quot;&gt;SOAP 章节&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;soapfault&quot;&gt;关于 SoapFault&lt;/h3&gt;

&lt;p&gt;服务端在处理客户端请求发生错误时，将会抛出 SoapFault 异常。对于 SOAP 扩展中，哪些方法可能会抛出异常可以查看手册。一旦发生了异常，我们都应该捕捉它们，并妥善处理。像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    $client = new SoapClient($wsdl, [
        &#39;trace&#39; =&amp;gt; true,
        &#39;soap_version&#39; =&amp;gt; SOAP_1_2
    ]);

    .....
} catch(SoapFault $e) {
    //在这里处理异常
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;getlastrequest--getlastresponse&quot;&gt;getLastRequest 和 getLastResponse&lt;/h3&gt;

&lt;p&gt;这两个方法可以查看最近一次请求和响应的内容，这两个方法对于调试很有帮助。当然，这两个方法只有在 &lt;code&gt;SoapClient&lt;/code&gt; 实例化时，&lt;code&gt;trace&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt; 才会生效。比如像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$wsdl = &#39;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl&#39;;
$client = new SoapClient($wsdl, [
    &#39;trace&#39; =&amp;gt; true,
    &#39;soap_version&#39; =&amp;gt; SOAP_1_2
]);

$client-&amp;gt;qqCheckOnline([
    &#39;qqCode&#39; =&amp;gt; 8698053
]));

echo $client-&amp;gt;__getLastRequest();
echo $client-&amp;gt;__getLastResponse();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getLastRequest() 输出的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;env:Envelope
    xmlns:env=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    xmlns:ns1=&quot;http://WebXml.com.cn/&quot;&amp;gt;
    &amp;lt;env:Body&amp;gt;
        &amp;lt;ns1:qqCheckOnline&amp;gt;
            &amp;lt;ns1:qqCode&amp;gt;8698053&amp;lt;/ns1:qqCode&amp;gt;
        &amp;lt;/ns1:qqCheckOnline&amp;gt;
    &amp;lt;/env:Body&amp;gt;
&amp;lt;/env:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getLastResponse() 输出的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;qqCheckOnlineResponse
            xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
            &amp;lt;qqCheckOnlineResult&amp;gt;Y&amp;lt;/qqCheckOnlineResult&amp;gt;
        &amp;lt;/qqCheckOnlineResponse&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;soapui-&quot;&gt;SoapUI 调试工具&lt;/h3&gt;

&lt;p&gt;在调试 SOAP 服务接口时，我们可以使用功能强大的 &lt;a href=&quot;http://www.soapui.org/&quot;&gt;SoapUI&lt;/a&gt; 工具，可以很方便地调试接口。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-8-18/soapui.png&quot;&gt;&lt;img src=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-8-18/soapui.png&quot; alt=&quot;SoapUI&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面都是自己在学习 PHP SOAP 扩展时的一些零散的笔记，如果有不对的地方，希望大家指出，谢谢。&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Sep 2015 23:18:44 +0800</pubDate>
        <link>http://aisuhua.github.io//blog/soap/2015/09/17/php-soap-note.html</link>
        <guid isPermaLink="true">http://aisuhua.github.io//blog/soap/2015/09/17/php-soap-note.html</guid>
        
        
        <category>soap</category>
        
      </item>
    
      <item>
        <title>PHP SOAP 扩展的使用</title>
        <description>&lt;p&gt;原文地址：&lt;a href=&quot;http://www.yeeyan.org/articles/view/jimmylee/5424&quot;&gt;PHP SOAP 扩展&lt;/a&gt;，本文在原文基础上添加了一些内容和章节，也加入了一些注释，请读者注意。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;PHP 的 SOAP 扩展可以用来提供和使用 Web Services。换句话说，PHP 开发者可以利用这个 PHP 扩展来写他们自己的 Web Services，也可以写一些客户端来使用给定的 Web Services。&lt;/p&gt;

&lt;p&gt;PHP5 中的这个 SOAP 扩展目的是为了实现 PHP 对 Web Services 的支持。与其它实现 PHP 对 Web Services 的支持的方法不同，SOAP 扩展是用 C 写的，因此它比其它方法具有速度优势。注：SOAP 扩展是在 PHP5 才开始提供，所以在此之前人们要使用 SOAP 去调用 Web Services 时，一般是使用第三方提供的 SOAP 封装库来实现，比如：&lt;a href=&quot;https://github.com/tinoadams/NuSOAP&quot;&gt;NuSOAP&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;SOAP 扩展支持以下规范：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SOAP 1.1&lt;/li&gt;
  &lt;li&gt;SOAP 1.2&lt;/li&gt;
  &lt;li&gt;WSDL 1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SOAP 扩展主要用来处理 RPC 形式的 Web Services。不过，你也可以使用文本形式的 WSDL 文件配合 WSDL 模式的服务端和客户端。&lt;/p&gt;

&lt;p&gt;这个扩展使用 &lt;a href=&quot;http://www.xmlsoft.org/&quot;&gt;GNOME XML&lt;/a&gt; 库来处理XML。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;扩展中的类&lt;/h2&gt;

&lt;p&gt;这个扩展实现了6个类。其中有三个高级的类，它们的方法很有用，它们是 SoapClient、SoapServer 和SoapFault。另外三个类除了构造器外没有其它别的方法，这三个是低级的类，它们是 SoapHeader、SoapParam 和 SoapVar。&lt;/p&gt;

&lt;p&gt;SOAP 扩展关系图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram.png&quot;&gt;&lt;img src=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram.png&quot; alt=&quot;SOAP 扩展关系图1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上图并不是很准确，因为 SoapServer 也可以在响应时发送 SoapHeader。所有会有下面这个更加准确的关系图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram_2.gif&quot;&gt;&lt;img src=&quot;http://7xluvh.com1.z0.glb.clouddn.com/2015-9-17soap_ext_class_diagram_2.gif&quot; alt=&quot;SOAP 扩展关系图2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;soapclient-&quot;&gt;SoapClient 类&lt;/h3&gt;

&lt;p&gt;这个类用来使用 Web Services。SoapClient 类可以作为给定 Web Services 的客户端。
它有两种操作形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WSDL 模式&lt;/li&gt;
  &lt;li&gt;Non-WSDL 模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 WSDL 模式中，构造器可以使用 WSDL 文件名作为参数，并自动从 WSDL 中提取使用服务时所需要的信息。&lt;/p&gt;

&lt;p&gt;Non-WSDL 模式中使用参数来设置使用服务时所需要的信息。这个类有许多可以用来使用服务的有用的方法。其中 SoapClient::__soapCall() 是最重要的。这个方法可以用来调用服务中的某个操作。&lt;/p&gt;

&lt;h3 id=&quot;soapserver-&quot;&gt;SoapServer 类&lt;/h3&gt;

&lt;p&gt;这个类可以用来提供 Web Services。与 SoapClient 类似，SoapServer 也有两种操作模式：WSDL 模式和 non-WSDL模式。这两种模式的意义跟 SoapClient 的两种模式一样。在 WSDL 模式中，服务实现了 WSDL 提供的接口；在 non-WSDL 模式中，参数被用来管理服务的行为。&lt;/p&gt;

&lt;p&gt;在 SoapServer 类的众多方法中，有三个方法比较重要。它们是 SoapServer::setClass()、SoapServer::addFunction() 和 SoapServer::handle()。&lt;/p&gt;

&lt;p&gt;SoapServer::setClass()方法设定用来实现 Web Services 的类。SoapServer::setClass 所设定的类中的所有公共方法将成为 Web Services 的操作（operation）。&lt;/p&gt;

&lt;p&gt;SoapServer::addFunction() 方法用来添加一个或多个作为 Web Services 操作（operation）的函数。&lt;/p&gt;

&lt;p&gt;SoapServer:: handle() 方法指示 Web Services 脚本开始处理进入的请求。Web Services 脚本是用 PHP 脚本写的一个或多个 SoapServer 对象的实例。尽管你可以有不止一个的 SoapServer 对象，但通常的习惯是一个脚本只拥有一个 SoapServer 实例。在调用 SoapServer::handle() 方法之前，Web Services 脚本会使用设置在 SoapServer 对象实例上的任何信息来处理进入的请求和输出相应的内容。&lt;/p&gt;

&lt;h3 id=&quot;soapfault-&quot;&gt;SoapFault 类&lt;/h3&gt;

&lt;p&gt;这个类从 Exception 类继承而来，可以用来处理错误。SoapFault 实例可以抛出或获取 Soap 错误的相关信息并按程序员的要求处理。&lt;/p&gt;

&lt;h3 id=&quot;soapheader-&quot;&gt;SoapHeader 类&lt;/h3&gt;

&lt;p&gt;这个类可以用来描述 SOAP headers。它只是一个只包含构造器方法的数据容器。&lt;/p&gt;

&lt;h3 id=&quot;soapparam-&quot;&gt;SoapParam 类&lt;/h3&gt;

&lt;p&gt;SoapParam 也是一个只包含构造器方法的数据容器。这个方法可以用来描述传递给 Web Services 操作的参数。在 non-WSDL 模式中这是一个很有用的类，可以用来传递所期望格式的参数信息。&lt;/p&gt;

&lt;h3 id=&quot;soapvar-&quot;&gt;SoapVar 类&lt;/h3&gt;

&lt;p&gt;SoapVar 也是一个只包含构造器的低级类，与 SoapHeader 和 SoapParam 类相似。这个类可以用来给一个Web Services 操作传递编码参数。这个类对 non-WSDL 中传递类型信息是非常有用的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;注：SoapParam 和 SoapVar 主要用来封装用于放入 SOAP 请求中的数据，他们主要在 non-WSDL 模式下使用。事实上，在 WSDL 模式下，SOAP 请求的参数可以通过数组方式包装，SOAP 扩展会根据 WSDL 文件将这个数组转化成为 SOAP 请求中的数据部分，所以并不需要这两个类。而在 non-WSDL 模式下，由于没有提供 WSDL 文件，所以必须通过这两个类进行包装。&lt;/p&gt;

&lt;p&gt;SoapHeader 类用来构造 SOAP 头，SOAP 头可以对 SOAP 的能力进行必要的扩展。SOAP 头的一个主要作用就是用于简单的身份认证。&lt;/p&gt;

&lt;h2 id=&quot;wsdl-vs-non-wsdl-&quot;&gt;WSDL VS. non-WSDL 模式&lt;/h2&gt;

&lt;p&gt;Web Services 有两种实现模式：契约先行（Contract first）模式和代码先行（Code first）模式。&lt;/p&gt;

&lt;p&gt;契约先行模式使用了一个用 XML 定义的服务接口的WSDL文件。WSDL 文件定义了服务必须实现或客户端可以使用的接口。SoapServer 和 SoapClient 的 WSDL 模式就基于这个概念。&lt;/p&gt;

&lt;p&gt;在代码先行模式中，首先要先写出实现服务的代码。然后在大多数情况下，代码会产生一个契约（可以借助一些工具生成），换种说法，一个 WSDL 文件。接着客户端在使用服务的时候就可以使用那个 WSDL 来获得服务的接口及其他信息。尽管如此，PHP5 的扩展并没有从代码输出一个 WSDL 的实现，考虑到这种情况，可以在 non-WSDL 模式下使用 SoapServer 和 SoapClient。&lt;/p&gt;

&lt;h2 id=&quot;soap--hello-world&quot;&gt;使用 SOAP 扩展实现 Hello World&lt;/h2&gt;

&lt;p&gt;这一节介绍如何使用 WSDL 模式和 non-WSDL 模式来实现服务和客户端。相对而言，使用 WSDL 模式来实现服务和客户端会比较容易，假定已经有一个定义好了接口的 WSDL 文件。因此这一节会先介绍如何使用 WSDL 模式实现一个 Web Service。&lt;/p&gt;

&lt;h3 id=&quot;soap-&quot;&gt;安装 SOAP 扩展&lt;/h3&gt;

&lt;p&gt;对于 Windows 平台，需要在 php.ini 中加入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension = php_soap.dll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的工作完成之后，还需要注意的是 SOAP 扩展在配置文件中有独立的代码片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[soap]
; Enables or disables WSDL caching feature.
; http://php.net/soap.wsdl-cache-enabled
soap.wsdl_cache_enabled=1

; Sets the directory name where SOAP extension will put cache files.
; http://php.net/soap.wsdl-cache-dir
soap.wsdl_cache_dir=&quot;D:/wamp/tmp&quot;

; (time to live) Sets the number of second while cached file will be used
; instead of original one.
; http://php.net/soap.wsdl-cache-ttl
soap.wsdl_cache_ttl=86400

; Sets the size of the cache limit. (Max. number of WSDL files to cache)
soap.wsdl_cache_limit = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些配置项主要是用来指定 PHP 处理 WSDL 文件时使用缓存的行为。这几个配置项分别说明：是否开启 WSDL 文件缓存、文件缓存位置、缓存时间、以及最大缓存文件数量。启用缓存会加快 PHP 处理 WSDL 文件的速度，但最好在调试代码时关闭缓存，以避免一些因缓存行为而出现的问题。&lt;/p&gt;

&lt;h3 id=&quot;wsdl-&quot;&gt;WSDL 文件&lt;/h3&gt;

&lt;p&gt;在这个 Hello World 例子的服务中有一个被命名为 greet 的操作。这个操作有一个字符串形式的名字参数并返回一个字符串形式的 Hello + 名字。所用到的 WSDL 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;wsdl:definitions
    xmlns:impl=&#39;http://localhost/php-soap/wsdl/helloService&#39;
    xmlns:intf=&#39;http://localhost/php-soap/wsdl/helloService&#39;
    xmlns:wsdl=&#39;http://schemas.xmlsoap.org/wsdl/&#39;
    xmlns:wsdlsoap=&#39;http://schemas.xmlsoap.org/wsdl/soap/&#39;
    xmlns:xsd=&#39;http://www.w3.org/2001/XMLSchema&#39; 
    targetNamespace=&#39;http://localhost/php-soap/wsdl/helloService&#39;&amp;gt;
    &amp;lt;wsdl:types&amp;gt;
        &amp;lt;schema elementFormDefault=&#39;qualified&#39;
            xmlns:impl=&#39;http://localhost/php-soap/wsdl/helloService&#39;
            xmlns:intf=&#39;http://localhost/php-soap/wsdl/helloService&#39;
            xmlns:wsdl=&#39;http://schemas.xmlsoap.org/wsdl/&#39;
            xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; 
            targetNamespace=&#39;http://localhost/php-soap/wsdl/helloService&#39; &amp;gt;
            &amp;lt;element name=&#39;greet&#39;&amp;gt;
                &amp;lt;complexType&amp;gt;
                    &amp;lt;sequence&amp;gt;
                        &amp;lt;element name=&#39;name&#39; type=&#39;xsd:string&#39; /&amp;gt;
                    &amp;lt;/sequence&amp;gt;
                &amp;lt;/complexType&amp;gt;
            &amp;lt;/element&amp;gt;
            &amp;lt;element name=&#39;greetResponse&#39;&amp;gt;
                &amp;lt;complexType&amp;gt;
                    &amp;lt;sequence&amp;gt;
                        &amp;lt;element name=&#39;greetReturn&#39; type=&#39;xsd:string&#39; /&amp;gt;
                    &amp;lt;/sequence&amp;gt;
                &amp;lt;/complexType&amp;gt;
            &amp;lt;/element&amp;gt;
        &amp;lt;/schema&amp;gt;
    &amp;lt;/wsdl:types&amp;gt;
    &amp;lt;wsdl:message name=&#39;greetRequest&#39;&amp;gt;
        &amp;lt;wsdl:part name=&#39;parameters&#39; element=&#39;impl:greet&#39; /&amp;gt;
    &amp;lt;/wsdl:message&amp;gt;
    &amp;lt;wsdl:message name=&#39;greetResponse&#39;&amp;gt;
        &amp;lt;wsdl:part name=&#39;parameters&#39; element=&#39;impl:greetResponse&#39; /&amp;gt;
    &amp;lt;/wsdl:message&amp;gt;
    &amp;lt;wsdl:portType name=&#39;helloService&#39;&amp;gt;
        &amp;lt;wsdl:operation name=&#39;greet&#39;&amp;gt;
            &amp;lt;wsdl:input name=&#39;greetRequest&#39; message=&#39;impl:greetRequest&#39; /&amp;gt;
            &amp;lt;wsdl:output name=&#39;greetResponse&#39; message=&#39;impl:greetResponse&#39; /&amp;gt;
        &amp;lt;/wsdl:operation&amp;gt;
    &amp;lt;/wsdl:portType&amp;gt;
    &amp;lt;wsdl:binding name=&#39;helloServiceSoapBinding&#39; type=&#39;impl:helloService&#39;&amp;gt;
        &amp;lt;wsdlsoap:binding transport=&#39;http://schemas.xmlsoap.org/soap/http&#39; style=&#39;document&#39; /&amp;gt;
        &amp;lt;wsdl:operation name=&#39;greet&#39;&amp;gt;
            &amp;lt;wsdlsoap:operation soapAction=&#39;helloService#greet&#39; /&amp;gt;
            &amp;lt;wsdl:input name=&#39;greetRequest&#39;&amp;gt;
                &amp;lt;wsdlsoap:body use=&#39;literal&#39; /&amp;gt;
            &amp;lt;/wsdl:input&amp;gt;
            &amp;lt;wsdl:output name=&#39;greetResponse&#39;&amp;gt;
                &amp;lt;wsdlsoap:body use=&#39;literal&#39; /&amp;gt;
            &amp;lt;/wsdl:output&amp;gt;
        &amp;lt;/wsdl:operation&amp;gt;
    &amp;lt;/wsdl:binding&amp;gt;
    &amp;lt;wsdl:service name=&#39;helloService&#39;&amp;gt;
        &amp;lt;wsdl:port binding=&#39;impl:helloServiceSoapBinding&#39; name=&#39;helloService&#39;&amp;gt;
            &amp;lt;wsdlsoap:address location=&#39;http://localhost/php-soap/wsdl/hello_service_wsdl.php&#39; /&amp;gt;
        &amp;lt;/wsdl:port&amp;gt;
    &amp;lt;/wsdl:service&amp;gt;
&amp;lt;/wsdl:definitions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;wsdl--1&quot;&gt;WSDL 模式服务端&lt;/h3&gt;

&lt;p&gt;下面是 WSDL 模式的服务使用 SOAP 扩展来实现提供服务的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
function greet($param)
{
    $value  = &#39;Hello &#39; . $param-&amp;gt;name;
    $result = [
        &#39;greetReturn&#39; =&amp;gt; $value
    ];
    return $result;
}

$server = new SoapServer(&#39;hello.wsdl&#39;);
$server-&amp;gt;addFunction(&#39;greet&#39;);
$server-&amp;gt;handle();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个服务的实现过程中，函数实现了WSDL所定义的服务操作 greet，greet 操作有一个 WSDL 指定的参数，按照 greet 操作的语义，这个参数是一个用户的名字。最后 handle 调用了触发处理请求的服务对象。&lt;/p&gt;

&lt;h3 id=&quot;wsdl--2&quot;&gt;WSDL 模式客户端&lt;/h3&gt;

&lt;p&gt;客户端代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    $client = new SoapClient(&#39;hello.wsdl&#39;);
    $result =  $client-&amp;gt;__soapCall(&#39;greet&#39;, [
        [&#39;name&#39; =&amp;gt; &#39;Suhua&#39;]
    ]);
    printf(&quot;Result = %s&quot;, $result-&amp;gt;greetReturn);
} catch (Exception $e) {
    printf(&quot;Message = %s&quot;,$e-&amp;gt;__toString());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端代码中，首先创建一个使用 WSDL 文件作参数的 SoapClient 实例。接着使用 __soapCall() 调用 greet 方法，并传入参数。&lt;/p&gt;

&lt;p&gt;下面是客户端所发送的 SOAP 请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;SOAP-ENV:Envelope
    xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:ns1=&quot;http://localhost/php-soap/wsdl/helloService&quot;&amp;gt;
    &amp;lt;SOAP-ENV:Body&amp;gt;
        &amp;lt;ns1:greet&amp;gt;
            &amp;lt;ns1:name&amp;gt;Suhua&amp;lt;/ns1:name&amp;gt;
        &amp;lt;/ns1:greet&amp;gt;
    &amp;lt;/SOAP-ENV:Body&amp;gt;
&amp;lt;/SOAP-ENV:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是服务端响应上诉请求而发送的 SOAP 响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;SOAP-ENV:Envelope
    xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:ns1=&quot;http://localhost/php-soap/wsdl/helloService&quot;&amp;gt;
    &amp;lt;SOAP-ENV:Body&amp;gt;
        &amp;lt;ns1:greetResponse&amp;gt;
            &amp;lt;ns1:greetReturn&amp;gt;Hello Suhua&amp;lt;/ns1:greetReturn&amp;gt;
        &amp;lt;/ns1:greetResponse&amp;gt;
    &amp;lt;/SOAP-ENV:Body&amp;gt;
&amp;lt;/SOAP-ENV:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 SOAP 消息都是利用 WSDL 模式下的服务端和客户端来获取的（可以使用 __getLastResponse 和 __getLastRequest 这两个方法获取，前提是客户端初始化时，要把 &lt;code&gt;trace&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt;）。也可以利用 non-WSDL 模式的服务端和客户端来产生与上面相同的 SOAP 消息。但是，PHP 代码必须有一点改变。下一节会说明如何使用 non-WSDL 模式。&lt;/p&gt;

&lt;h3 id=&quot;non-wsdl-&quot;&gt;non-WSDL 模式服务端&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function greet($param)
{
    $value = &#39;Hello &#39;.$param;
    return new SoapParam($value, &#39;greetReturn&#39;);
}

$server = new SoapServer(null, [
    &#39;uri&#39; =&amp;gt; &#39;http://localhost/php-soap/non-wsdl/helloService&#39;
]);

$server-&amp;gt;addFunction(&#39;greet&#39;);
$server-&amp;gt;handle();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 non-WSDL 模式中，像 WSDL 模式一样首先实现 greet 函数的功能，但是函数实现的方式跟 WSDL 模式稍稍有所不同。在 non-WSDL 模式中，我们必须返回一个 SoapParam 对象作为响应，而不是一个数组。创建服务时，第一个参数设为 null，说明没有提供 WSDL；接着传递一个选项作为参数，这个选项参数是服务的 URI。最后像 WSDL 模式一样调用剩下的方法。&lt;/p&gt;

&lt;h3 id=&quot;non-wsdl--1&quot;&gt;non-WSDL 模式客户端&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;try {
    $client = new SoapClient(null, [
        &#39;location&#39; =&amp;gt; &#39;http://localhost/php-soap/non-wsdl/hello_service_non_wsdl.php&#39;,
        &#39;uri&#39; =&amp;gt; &#39;http://localhost/php-soap/non-wsdl/helloService&#39;
    ]);

    $result =  $client-&amp;gt;__soapCall(&#39;greet&#39;, [
        new SoapParam(&#39;Suhua&#39;, &#39;name&#39;)
    ]);

    printf(&quot;Result = %s&quot;, $result);
} catch (Exception $e) {
    printf(&quot;Message = %s&quot;,$e-&amp;gt;__toString());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 non-WSDL 模式中，因为没有使用 WSDL，传递了一个包含服务所在位置（location）和服务 URI 的参数数组作为参数。然后像 WSDL 模式中一样调用 __soapCall() 方法，但是使用了 SoapParam 类用指定格式打包参数。返回的结果将获取 greet 方法的响应。&lt;/p&gt;

&lt;p&gt;注：客户端实例化时所传入的服务 URI，实际上，我们可以把它看作该服务的一个命名空间（namespace）。客户端所传入的 URI 必与服务端所命名的 URI 一样。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;这篇文章介绍了 SOAP 扩展，可以在 PHP 中通过它来提供和使用 Web Services。PHP SOAP 扩展的强项是它的简单和快速。使用 C 写的 SOAP 扩展来运行服务端和客户端是非常简单的。虽然 SOAP 扩展在处理一些简单的 Web Services 时很有用，但是当用它来处理所有的 Web Services 时就表现出它的局限性。&lt;a href=&quot;http://wso2.com/products/web-services-framework/php/&quot;&gt;WSO WSF/PHP&lt;/a&gt; 就是为了弥补 PHP 扩展的缺陷而开发的，它是开源的，可以实现 SOAP 类似的功能并且支持 MTOM，WS-Addressing，WS- Security 和 WS-RelaiableMessaging。WSO2 WSF/PHP 支持与 SOAP 扩展类似的 API。我们正计划将 API 打包起来提供跟 SOAP 扩展一样的 API，会用 C 来写。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;这篇文章的原文 &lt;a href=&quot;http://wso2.com/library/1060/&quot;&gt;PHP SOAP Extension&lt;/a&gt;，中文译文 &lt;a href=&quot;http://www.yeeyan.org/articles/view/jimmylee/5424&quot;&gt;PHP SOAP     扩展&lt;/a&gt;。在转载这篇文章的时候，对文章添加了一些注释以及本人的一些见解，而且例子也是重新编写的，所以与原文比会有所不同。本文的所有代码将会被放到 &lt;a href=&quot;https://github.com/aisuhua&quot;&gt;Github&lt;/a&gt; 仓库中，方便以后翻阅和复习。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yeeyan.org/articles/view/jimmylee/5424&quot;&gt;PHP SOAP 扩展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wso2.com/library/1060/&quot;&gt;PHP SOAP Extension &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lfq618/article/details/5514641&quot;&gt;PHP SOAP 扩展详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 17 Sep 2015 17:18:44 +0800</pubDate>
        <link>http://aisuhua.github.io//blog/soap/2015/09/17/php-soap-tutorial.html</link>
        <guid isPermaLink="true">http://aisuhua.github.io//blog/soap/2015/09/17/php-soap-tutorial.html</guid>
        
        
        <category>soap</category>
        
      </item>
    
      <item>
        <title>SOAP Web 服务介绍</title>
        <description>&lt;p&gt;已经跨入 2015 年，当今最为常见的两种 Web 服务类型分别是： REST 和 SOAP 。不过，从趋势来看，越来越多人已经开始使用 REST 风格的 Web 服务。而 SOAP 大多也开始或已经转型 REST，应该说 REST 会慢慢成为主流。这篇文章不会对 REST 介绍太多，主要的重点还是介绍一下 SOAP 风格的 Web 服务。&lt;/p&gt;

&lt;h2 id=&quot;web-service-&quot;&gt;Web Service 三要素&lt;/h2&gt;

&lt;p&gt;实际上，现在说 “Web Service 三要素”应该是不算很准确了，不过这个概念一直这样沿用，而且本文我们为了更能清楚阐释 SOAP Web 服务，那么就这样定义。&lt;/p&gt;

&lt;p&gt;Web Service 的三个要素分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SOAP（Simple Object Access Protoco） 简单对象访问协议；&lt;/li&gt;
  &lt;li&gt;WSDL（Web Services Description Language） 网络服务描述语言；&lt;/li&gt;
  &lt;li&gt;UDDI（Universal Description Discovery and Integration）一个用来发布和搜索 WEB 服务的协议（非必须）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SOAP 用来描述传递信息的格式规范， WSDL 用来描述如何访问具体的接口（比如它会告诉你该服务有哪些接口可以使用，参数是什么等等）， UDDI 用来管理、分发和查询 Web Service。下面我们将逐一详细介绍这三个要素，并通过结合实例来进行阐释。&lt;/p&gt;

&lt;p&gt;为了把这三个要素说得更清楚，我们将会使用一个免费的 SOAP Web 服务作为例子进行阐述。该服务只提供一个接口即：根据 QQ 号，获取 QQ 在线状态。&lt;a href=&quot;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx&quot;&gt;查看该服务&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;soap&quot;&gt;SOAP&lt;/h2&gt;

&lt;p&gt;它是一个协议，可以简单的理解为：它定义了一个基于 XML 的可扩展消息信封格式。因为客户端与服务器进行交互，由于大家的平台和应用程序都不一样，所以大家约定都采用 SOAP 这个协议来规范交互时的需要传递的消息。&lt;/p&gt;

&lt;p&gt;请求接口时，发送的消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;qqCheckOnline xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
            &amp;lt;qqCode&amp;gt;8698053&amp;lt;/qqCode&amp;gt;
        &amp;lt;/qqCheckOnline&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口响应时，返回的消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;qqCheckOnlineResponse xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
            &amp;lt;qqCheckOnlineResult&amp;gt;Y&amp;lt;/qqCheckOnlineResult&amp;gt;
        &amp;lt;/qqCheckOnlineResponse&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：以上例子是使用 SOAP 1.1 发送的消息，SOAP 1.2 发送的消息格式其实大同小异，具体自己&lt;a href=&quot;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?op=qqCheckOnline&quot;&gt;查看接口文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面对它结构进行详细说明。&lt;/p&gt;

&lt;h3 id=&quot;xml-&quot;&gt;XML 声明&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码（utf-8）。&lt;/p&gt;

&lt;h3 id=&quot;envelope-&quot;&gt;Envelope 元素&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt;
	....
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Envelope&lt;/code&gt; 元素是 SOAP 消息的固定根元素，SOAP 协议规定的，不能变，其中 &lt;code&gt;xmlns&lt;/code&gt; 是 XML Namespace 的缩写，表示 XML 命名空间。&lt;code&gt;xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&lt;/code&gt; 是 &lt;code&gt;Envelope&lt;/code&gt;的一个属性，它表示定义个以 &lt;code&gt;soap&lt;/code&gt; 为前缀的命名空间 &lt;code&gt;http://schemas.xmlsoap.org/soap/envelope/&lt;/code&gt;，即命名空间的名字是：&lt;code&gt;http://schemas.xmlsoap.org/soap/envelope/&lt;/code&gt;，而它的前缀是 &lt;code&gt;soap&lt;/code&gt;，这样子就把 &lt;code&gt;soap&lt;/code&gt; 前缀与该命名空间进行了绑定。即任何用 &lt;code&gt;soap&lt;/code&gt; 为前缀的元素都属于该命名空间的，包括根元素 &lt;code&gt;Envelope&lt;/code&gt; 。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;qqCheckOnline xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
            &amp;lt;qqCode&amp;gt;8698053&amp;lt;/qqCode&amp;gt;
        &amp;lt;/qqCheckOnline&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;Envelope&lt;/code&gt; 和 &lt;code&gt;Body&lt;/code&gt; 元素就是以 &lt;code&gt;soap&lt;/code&gt; 为前缀的，那么 &lt;code&gt;Envelope&lt;/code&gt; 和 &lt;code&gt;Body&lt;/code&gt; 元素都是属于 &lt;code&gt;http://schemas.xmlsoap.org/soap/envelope/&lt;/code&gt; 这个命名空间的。&lt;/p&gt;

&lt;p&gt;同时，SOAP 协议中规定，SOAP 消息必须使用 SOAP Envelope 命名空间，所以 &lt;code&gt;http://schemas.xmlsoap.org/soap/envelope/&lt;/code&gt; 这个命名空间是固定的不能变（注意：这里只针对 SOAP 1.1 版本，SOAP 1.2 会有所不同）。所有 SOAP 消息元素，比如：&lt;code&gt;Envelope&lt;/code&gt;、&lt;code&gt;Header&lt;/code&gt;、&lt;code&gt;Body&lt;/code&gt;、&lt;code&gt;Fault&lt;/code&gt; 也都必须属于该命名空间。&lt;/p&gt;

&lt;h3 id=&quot;body-&quot;&gt;Body 元素&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Body&amp;gt;
    &amp;lt;qqCheckOnline xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
        &amp;lt;qqCode&amp;gt;8698053&amp;lt;/qqCode&amp;gt;
    &amp;lt;/qqCheckOnline&amp;gt;
&amp;lt;/soap:Body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Body&lt;/code&gt; 元素里面，一般都是放一些请求和响应的内容。&lt;code&gt;qqCheckOnline&lt;/code&gt; 表示要调用的接口方法，而 &lt;code&gt;qqCode&lt;/code&gt; 就是调用该方法时，传入的参数，当然参数可以有多个。&lt;/p&gt;

&lt;p&gt;其中，&lt;code&gt;qqCheckOnline&lt;/code&gt; 元素上也定义了一个命名空间 &lt;code&gt;http://WebXml.com.cn/&lt;/code&gt;。值得注意的是，这里在定义命名空间时，并没有设置命名空间前缀（namespace prefix）。这种设置方式，会把当前元素及其所有子元素，都归属于该命名空间。&lt;a href=&quot;http://www.w3school.com.cn/xml/xml_namespaces.asp&quot;&gt;了解 XML 命名空间&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们看到，SOAP 消息元素和应用程序本身的元素是属于不同的命名空间，这样有利于把 SOAP 消息元素与其他元素区分开来，当然也防止了与自定义元素重名的问题。&lt;/p&gt;

&lt;h3 id=&quot;header-&quot;&gt;Header 元素&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
    &amp;lt;soap:Header&amp;gt;
        &amp;lt;AuthenHeader xmlns=&quot;http://www.example.com&quot;&amp;gt;
            &amp;lt;sAuthenticate&amp;gt;string&amp;lt;/sAuthenticate&amp;gt;
        &amp;lt;/AuthenHeader&amp;gt;
    &amp;lt;/soap:Header&amp;gt;
    &amp;lt;soap:Body&amp;gt;
	......
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些接口需要提供 &lt;code&gt;Header&lt;/code&gt; 元素，它和 &lt;code&gt;Body&lt;/code&gt; 信息一起发送，它一般用于身份验证等作用。例子中的 &lt;code&gt;AuthenHeader&lt;/code&gt; 和 &lt;code&gt;sAuthenticate&lt;/code&gt; 都是接口自定义的参数。&lt;/p&gt;

&lt;h3 id=&quot;fault-&quot;&gt;Fault 元素&lt;/h3&gt;

&lt;p&gt;当调用服务发生错误时，错误信息一般会被放置在 &lt;code&gt;Fault&lt;/code&gt; 元素内。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;soap:Fault&amp;gt;
            &amp;lt;faultcode&amp;gt;soap:Client&amp;lt;/faultcode&amp;gt;
            &amp;lt;faultstring&amp;gt;Input string was not in a correct format.&amp;lt;/faultstring&amp;gt;
            &amp;lt;detail/&amp;gt;
        &amp;lt;/soap:Fault&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fault 元素内还有 &lt;code&gt;faultcode&lt;/code&gt;、&lt;code&gt;faultstring&lt;/code&gt;、&lt;code&gt;detail&lt;/code&gt;，用于描述错误信息用的。在上一篇文章：《SOAP 介绍》中已经对该知识点进行了比较详细的说明，有兴趣可以看看。&lt;/p&gt;

&lt;h2 id=&quot;wsdl&quot;&gt;WSDL&lt;/h2&gt;

&lt;p&gt;一个 XML 格式的文档。它用于描述该服务有哪些可用方法、参数的数据类型、命名空间等等信息。它的目的是让你知道该如何使用该服务，包括调用的各种细节信息。WSDL 文档通常用来辅助生成服务器和客户端代码及配置信息。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;契约先行与代码先行模式&lt;/h3&gt;

&lt;p&gt;在开发 Web Service 过程中有两种实现模式：契约先行（Contract first）模式和代码先行（Code first）模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;契约先行模式&lt;/strong&gt;：首要工作是定义针对这个 Web 服务的接口的 WSDL(Web Services Description Language，Web 服务描述语言 ) 文件。WSDL 文件中描述了 Web 服务的位置，可提供的操作集，以及其他一些属性。WSDL 文件也就是 Web 服务的 “契约”。“契约” 订立之后，再据此进行服务器端和客户端的应用程序开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码先行模式&lt;/strong&gt;：与契约先行模式不同，代码先行模式中，第一步工作是实现 Web 服务端，然后根据服务端的实现，用某种方法（自动生成或手工编写）生成 WSDL 文件。&lt;/p&gt;

&lt;p&gt;实际上，一个 WSDL 文件也挺复杂的，一般自己也不会去直接看这个文件，而是需要用到某个方法时，直接看该方法的调用说明就好。比如：&lt;a href=&quot;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?op=qqCheckOnline&quot;&gt;获得腾讯QQ在线状态&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;uddi&quot;&gt;UDDI&lt;/h2&gt;

&lt;p&gt;UDDI 是一个专门用来管理 Web 服务的地方。Web Service 服务提供商可以通过两种方式来暴露它的 WSDL 文件地址：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注册到 UDDI 服务器，以便被人查找；&lt;/li&gt;
  &lt;li&gt;直接告诉给客户端调用者；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是否需要注册到 UDDI 实际上是可选的，一般公司内部使用的服务，也不会注册到 UDDI。只有那些希望所有人都知道该服务的地址，才会注册到 UDDI。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;这篇文章写得有点乱了，主要还是自己对 SOAP 的了解还不够，最起码我并没有真正开发过 SOAP 服务。不过没关系吧，慢慢来，文章可以随着知识的增长慢慢润色。上文其实有一些问题没有说清楚的，比如说：SOAP 服务的适合用在哪里，不适合用在哪里等等。如果你有兴趣，可以看看文章最后的几篇参考文献。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=dWy5VmzeqzGhJxcTNO42FqJ1nLH3cwKfOdaJ9YfR5T3eFSPRQkP-xJQQNABi_hvBN_qNsWxj1P1U6rwvvafUOfgoZNZlGssdq48XYhjK3M91lFj1T0SucuAtavpr8ZEirrVFLzcALpol1SMG0fePmK&quot;&gt;简单对象访问协议（百度百科）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1&quot;&gt;Web服务&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yeeyan.org/articles/view/jimmylee/5424&quot;&gt;PHP SOAP 扩展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/wooshn/article/details/8069087&quot;&gt;Web Service 到底是什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;其他&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;获得腾讯QQ在线状态服务：&lt;a href=&quot;http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx&quot;&gt;qqCheckOnline&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;SOAP 服务调试工具：&lt;a href=&quot;http://www.soapui.org/&quot;&gt;SoapUI 5.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;XML 在线格式化工具：&lt;a href=&quot;http://www.webtoolkitonline.com/xml-formatter.html&quot;&gt;Web Toolkit Online&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 16 Sep 2015 17:18:44 +0800</pubDate>
        <link>http://aisuhua.github.io//blog/soap/2015/09/16/soap-web-service.html</link>
        <guid isPermaLink="true">http://aisuhua.github.io//blog/soap/2015/09/16/soap-web-service.html</guid>
        
        
        <category>soap</category>
        
      </item>
    
      <item>
        <title>SOAP 介绍</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;SOAP（Simple Object Access Protoco）简单对象访问协议是在分散或分布式的环境中交换信息的简单的协议，是一个基于 XML 的协议。此协议规范由 IBM、Microsoft、UserLand 和 DevelopMentor 在1998年共同提出，并得到 IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C）。现在，SOAP 协议规范由万维网联盟的 XML工作组维护。SOAP 1.2 版在2003年6月24日成为 W3C 的推荐版本。&lt;/p&gt;

&lt;p&gt;SOAP 协议包括以下四个部分的内容：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SOAP 封装（envelop），封装定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它以及如何处理它们的框架；&lt;/li&gt;
  &lt;li&gt;SOAP 编码规则（encoding rules），它定义了不同应用程序间交换信息时，需要使用到的数据类型；&lt;/li&gt;
  &lt;li&gt;SOAP RPC 表示（RPC representation），它定义了一个表示远程过程调用和应答的协定；&lt;/li&gt;
  &lt;li&gt;SOAP 绑定（binding），它定义 SOAP 使用哪种底层协议交换信息的协定。使用 HTTP/TCP/UDP 协议都可以；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;四个部分之间的关系&lt;/h3&gt;

&lt;p&gt;SOAP 消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。所有的 SOAP 消息都使用 XML 编码。一条 SOAP 消息就是一个包含有一个必需的 SOAP 的封装包，一个可选的 SOAP 标头（Header）和一个必需的 SOAP 体块（Body）的 XML 文档。&lt;/p&gt;

&lt;p&gt;把 SOAP 绑定到 HTTP 提供了同时利用 SOAP 的样式和分散的灵活性的特点以及 HTTP 的丰富的特征库的优点。在HTTP上传送 SOAP 并不是说 SOAP 会覆盖现有的 HTTP 语义，而是 HTTP 上的 SOAP 语义会自然的映射到 HTTP 语义。在使用 HTTP 作为协议绑定的场合中， RPC 请求映射到 HTTP 请求上，而 RPC 应答映射到 HTTP 应答。然而，在 RPC 上使用 SOAP 并不仅限于 HTTP 协议绑定。SOAP也可以绑定到TCP和UDP协议上。&lt;/p&gt;

&lt;p&gt;虽然这四个部分都作为 SOAP 的一部分，作为一个整体定义的，但他们在功能上是相交的、彼此独立的。特别的，信封（envelop）和编码规则（encoding rules）是被定义在不同的 XML 命名空间中，这样使得定义更加简单。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;语法规则&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SOAP 消息必须用 XML 来编码；&lt;/li&gt;
  &lt;li&gt;SOAP 消息必须使用 SOAP Envelope 命名空间；&lt;/li&gt;
  &lt;li&gt;SOAP 消息必须使用 SOAP Encoding 命名空间；&lt;/li&gt;
  &lt;li&gt;SOAP 消息不能包含 DTD 引用；&lt;/li&gt;
  &lt;li&gt;SOAP 消息不能包含 XML 处理指令；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;soap-&quot;&gt;SOAP 消息格式&lt;/h2&gt;

&lt;p&gt;SOAP 消息的格式比较简单，如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/SOAP.svg/225px-SOAP.svg.png&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/SOAP.svg/225px-SOAP.svg.png&quot; alt=&quot;SOAP 消息格式&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是一条 SOAP 消息的基本格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Header&amp;gt;
        &amp;lt;!-- 消息头，可选 --&amp;gt;
    &amp;lt;/soap:Header&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;!-- 消息内容，必需 --&amp;gt;

        &amp;lt;soap:Fault&amp;gt;
            &amp;lt;!-- 错误信息，可选 --&amp;gt;
        &amp;lt;/soap:Fault&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一条 SOAP 消息就是一个普通的 XML 文档，包含如下元素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;必需的 Envelope 元素，据此可把该 XML 文档标识为一条 SOAP 消息；&lt;/li&gt;
  &lt;li&gt;可选的 Header 元素，包含头部信息，一般用于身份验证；&lt;/li&gt;
  &lt;li&gt;必需的 Body 元素，包含所有的调用和响应信息；&lt;/li&gt;
  &lt;li&gt;可选的 Fault 元素，提供有关在处理此消息时，所发生的错误的描述信息；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;语法规则详解&lt;/h2&gt;

&lt;h3 id=&quot;soap-envelope&quot;&gt;SOAP Envelope&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Envelope&lt;/code&gt; 是 SOAP 消息结构的主要容器，也是 SOAP 消息的根元素，它必须出现在每个 SOAP 消息中，用于把此 XML 文档标示为一条 SOAP 消息。&lt;/p&gt;

&lt;p&gt;在 SOAP 中，使用命名空间将 SOAP 消息元素与应用程序自定义的元素区分开来，将 SOAP 消息元素的作用域限制在一个特定的区域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SOAP 的 &lt;code&gt;encodingStyle&lt;/code&gt; 属性用于定义在文档中使用的数据类型。此属性可出现在任何 SOAP 元素中，并会被应用到元素的内容及元素的所有子元素上。&lt;/p&gt;

&lt;h3 id=&quot;soap-header&quot;&gt;SOAP Header&lt;/h3&gt;

&lt;p&gt;这个是可选的，如果需要添加 &lt;code&gt;Header&lt;/code&gt; 元素，那么它必须是 &lt;code&gt;Envelope&lt;/code&gt; 的第一个子元素。&lt;code&gt;Header&lt;/code&gt; 还可以包含0个或多个可选的子元素，这些子元素称为 Header 项，所有的 Header 项一般来说是属于某个特定与接口相关的命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Header&amp;gt;
        &amp;lt;AuthenHeader xmlns=&quot;http://www.example.com&quot;&amp;gt;
            &amp;lt;sAuthenticate&amp;gt;string&amp;lt;/sAuthenticate&amp;gt;
        &amp;lt;/AuthenHeader&amp;gt;
    &amp;lt;/soap:Header&amp;gt;
    &amp;lt;soap:Body&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Header&lt;/code&gt; 元素用于与消息一起传输一些附加的消息，如身份验证信息等。&lt;/p&gt;

&lt;h2 id=&quot;soap-body&quot;&gt;SOAP Body&lt;/h2&gt;

&lt;p&gt;SOAP 消息的 &lt;code&gt;Body&lt;/code&gt; 元素可以包含以下任何元素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;远程过程调用（RPC）的方法及其参数；&lt;/li&gt;
  &lt;li&gt;目标应用程序（消息接收者即接口调用者）所需要的数据；&lt;/li&gt;
  &lt;li&gt;报告故障和状态消息的 SOAP Fault；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所有 &lt;code&gt;Body&lt;/code&gt; 元素的直接子元素都称为 Body 项，所有 Body 项一般是属于某个特点的命名空间的。&lt;/p&gt;

&lt;p&gt;SOAP 请求消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;getMobileCodeInfo xmlns=&quot;http://www.example.com&quot;&amp;gt;
            &amp;lt;mobileCode&amp;gt;string&amp;lt;/mobileCode&amp;gt;
            &amp;lt;userID&amp;gt;string&amp;lt;/userID&amp;gt;
        &amp;lt;/getMobileCodeInfo&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SOAP 响应消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;getMobileCodeInfoResponse xmlns=&quot;http://www.example.com&quot;&amp;gt;
            &amp;lt;getMobileCodeInfoResult&amp;gt;string&amp;lt;/getMobileCodeInfoResult&amp;gt;
        &amp;lt;/getMobileCodeInfoResponse&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：以上例子表示通过手机号获取手机号归属地等信息。第一个例子是请求消息，第二个例子是它的响应消息。&lt;/p&gt;

&lt;h2 id=&quot;soap-fault&quot;&gt;SOAP Fault&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Fault&lt;/code&gt; 元素用于在 SOAP 消息中传输错误及状态信息。如果 SOAP 消息中包括 &lt;code&gt;Fault&lt;/code&gt; 元素，它必须作为一个 &lt;code&gt;Body&lt;/code&gt; 的子元素出现，而且至多出现一次。&lt;code&gt;Fault&lt;/code&gt; 元素本身也包含有描述错误详细信息的子元素。它包含以下子元素：&lt;code&gt;faultcode&lt;/code&gt;，&lt;code&gt;faultstring&lt;/code&gt;，&lt;code&gt;faultactor&lt;/code&gt;，&lt;code&gt;detail&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;子元素&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;faultcode&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;供识别故障的代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;faultstring&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;可供人阅读的有关故障的说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;faultactor&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;有关是谁引发故障的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;detail&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;有关涉及 &lt;code&gt;Body&lt;/code&gt; 元素的应用程序专用错误信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中 &lt;code&gt;faultcode&lt;/code&gt; 是每一条错误消息都会提供的元素，它的值一般是以下错误代码之一：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;错误代码&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;VersionMismatch&lt;/td&gt;
      &lt;td&gt;无效的 SOAP Envelope 命名空间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MustUnderstand&lt;/td&gt;
      &lt;td&gt;无法理解 &lt;code&gt;Header&lt;/code&gt; 中拥有属性 &lt;code&gt;mustUnderstand = 1&lt;/code&gt; 的子元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Client&lt;/td&gt;
      &lt;td&gt;消息结构错误，或包含了不正确的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Server&lt;/td&gt;
      &lt;td&gt;服务器出现错误&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：以上关于 SOAP Fault 的描述不完全适用于 SOAP 1.2 版本。因为 SOAP 1.2 版本在返回错误信息时，&lt;code&gt;Fault&lt;/code&gt; 的子元素及其内容已经有所不同。具体看下面的例子：&lt;/p&gt;

&lt;p&gt;SOAP v1.1 错误消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; 
    soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;soap:Fault&amp;gt;
            &amp;lt;faultcode&amp;gt;soap:Client&amp;lt;/faultcode&amp;gt;
            &amp;lt;faultstring&amp;gt;Input string was not in a correct format.&amp;lt;/faultstring&amp;gt;
        &amp;lt;detail/&amp;gt;
    &amp;lt;/soap:Fault&amp;gt;
&amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SOAP v1.2 错误消息例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope
    xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
    soap:encodingStyle=&quot;http://www.w3.org/2003/05/soap-encoding&quot;&amp;gt;
    &amp;lt;soap:Body&amp;gt;
        &amp;lt;soap:Fault&amp;gt;
            &amp;lt;soap:Code&amp;gt;
                &amp;lt;soap:Value&amp;gt;soap:Sender&amp;lt;/soap:Value&amp;gt;
            &amp;lt;/soap:Code&amp;gt;
            &amp;lt;soap:Reason&amp;gt;
                &amp;lt;soap:Text xml:lang=&quot;en&quot;&amp;gt;Input string was not in a correct format.&amp;lt;/soap:Text&amp;gt;
            &amp;lt;/soap:Reason&amp;gt;
            &amp;lt;soap:Detail/&amp;gt;
        &amp;lt;/soap:Fault&amp;gt;
    &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上返回结果来看，其实所返回的错误信息内容并没有太多改变，只是 XML 的元素发生了一些变化，具体还需要读者自己理解。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文章节有点乱，还算是把 SOAP 的基本知识点都过了一遍。接下来，我将会结合一些实例，进一步说明 SOAP 的特点以及如何使用 SOAP Web 服务。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/xml/x-sisoap/&quot;&gt;浅谈 SOAP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/wooshn/article/details/8145763&quot;&gt;SOAP 详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=dWy5VmzeqzGhJxcTNO42FqJ1nLH3cwKfOdaJ9YfR5T3eFSPRQkP-xJQQNABi_hvBN_qNsWxj1P1U6rwvvafUOfgoZNZlGssdq48XYhjK3M91lFj1T0SucuAtavpr8ZEirrVFLzcALpol1SMG0fePmK&quot;&gt;简单对象访问协议（百度百科）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/SOAP&quot;&gt;简单对象访问协议（维基百科）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/xml/xml_namespaces.asp&quot;&gt;XML 命名空间（XML Namespaces）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html&quot;&gt;SOAP 和 WSDL 的一些必要知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_3d7bed65010004vo.html&quot;&gt;WebService 笔记=&amp;gt;SOAP 消息结构 &lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-6&quot;&gt;其他&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;查询手机归属地信息服务：&lt;a href=&quot;http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx&quot;&gt;http://webXml.com.cn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;SOAP 服务调试工具：&lt;a href=&quot;http://www.soapui.org/&quot;&gt;SoapUI 5.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;XML 在线格式化工具：&lt;a href=&quot;http://www.webtoolkitonline.com/xml-formatter.html&quot;&gt;Web Toolkit Online&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 12 Sep 2015 01:40:44 +0800</pubDate>
        <link>http://aisuhua.github.io//blog/soap/2015/09/12/soap-brief-analysis.html</link>
        <guid isPermaLink="true">http://aisuhua.github.io//blog/soap/2015/09/12/soap-brief-analysis.html</guid>
        
        
        <category>soap</category>
        
      </item>
    
      <item>
        <title>世界，你好</title>
        <description>&lt;p&gt;想见证从菜鸟到大神的进化过程吗？在这里你将一目了然。（疯子一个）&lt;/p&gt;

&lt;p&gt;本博客主要记载一些技术性的文章，还有一些生活的体验。有人说“做技术，要有所为，有所不为”，那我就只能尽力而为吧。&lt;/p&gt;

&lt;p&gt;感谢你能够在这里停留，我会觉得很幸运 ^_^  谢谢你。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 May 2015 05:15:49 +0800</pubDate>
        <link>http://aisuhua.github.io//blog/php/2015/05/25/hello-world.html</link>
        <guid isPermaLink="true">http://aisuhua.github.io//blog/php/2015/05/25/hello-world.html</guid>
        
        
        <category>php</category>
        
      </item>
    
  </channel>
</rss>
